/* fit-parser.c generated by valac 0.28.1, the Vala compiler
 * generated from fit-parser.vala, do not modify */

/* Gpx Viewer
 * Copyright (C) 2013-2015 Qball Cow <qball@sarine.nl>
 * Project homepage: http://blog.sarine.nl/

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <glib.h>
#include <glib-object.h>
#include "gpx.h"
#include <gio/gio.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define GPX_FIT_FILE_TYPE_FIELD_DEFINITION (gpx_fit_file_field_definition_get_type ())

#define GPX_FIT_FILE_TYPE_FIELD_DEFINITION_HEADER (gpx_fit_file_field_definition_header_get_type ())
typedef struct _GpxFitFileFieldDefinitionHeader GpxFitFileFieldDefinitionHeader;
typedef struct _GpxFitFileFieldDefinition GpxFitFileFieldDefinition;

#define GPX_FIT_FILE_TYPE_FIT_TYPES (gpx_fit_file_fit_types_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _gpx_point_unref0(var) ((var == NULL) ? NULL : (var = (gpx_point_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GpxFitFileFieldDefinitionHeader {
	guint8 def_num;
	guint8 size;
	guint8 base_type;
};

struct _GpxFitFileFieldDefinition {
	gboolean endian;
	guint16 type;
	GpxFitFileFieldDefinitionHeader* fields;
	gint fields_length1;
	gint _fields_size_;
};

struct _GpxFitFilePrivate {
	GpxTrack* track;
	guint32 data_length;
	GpxFitFileFieldDefinition* defs;
	gint defs_length1;
	gint _defs_size_;
};

typedef enum  {
	GPX_FIT_FILE_FIT_TYPES_LAP = 19,
	GPX_FIT_FILE_FIT_TYPES_ACTIVITY_SUMMARY = 20
} GpxFitFileFitTypes;


static gpointer gpx_fit_file_parent_class = NULL;

#define MAX_LOCAL_DEFINITIONS 16
static GType gpx_fit_file_field_definition_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType gpx_fit_file_field_definition_header_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GpxFitFileFieldDefinitionHeader* gpx_fit_file_field_definition_header_dup (const GpxFitFileFieldDefinitionHeader* self);
static void gpx_fit_file_field_definition_header_free (GpxFitFileFieldDefinitionHeader* self);
static GpxFitFileFieldDefinition* gpx_fit_file_field_definition_dup (const GpxFitFileFieldDefinition* self);
static void gpx_fit_file_field_definition_free (GpxFitFileFieldDefinition* self);
static void gpx_fit_file_field_definition_copy (const GpxFitFileFieldDefinition* self, GpxFitFileFieldDefinition* dest);
static void gpx_fit_file_field_definition_destroy (GpxFitFileFieldDefinition* self);
#define GPX_FIT_FILE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPX_TYPE_FIT_FILE, GpxFitFilePrivate))
enum  {
	GPX_FIT_FILE_DUMMY_PROPERTY
};
static GType gpx_fit_file_fit_types_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void _vala_GpxFitFileFieldDefinition_array_free (GpxFitFileFieldDefinition* array, gint array_length);
static GpxFitFileFieldDefinition* gpx_fit_file_get_field_def (GpxFitFile* self, guint id);
static void gpx_fit_file_parse_apply_definition_endian (GpxFitFile* self, GDataInputStream* fs, GpxFitFileFieldDefinition* def);
static void gpx_fit_file_parse_header (GpxFitFile* self, GDataInputStream* fs, GError** error);
static gboolean gpx_fit_file_parse_record (GpxFitFile* self, GDataInputStream* fs);
static void gpx_fit_file_parse_definition_record (GpxFitFile* self, GDataInputStream* fs, guint8 local_message_type, GError** error);
static void gpx_fit_file_parse_data_record (GpxFitFile* self, GDataInputStream* fs, guint8 local_message_type, GError** error);
static guint32 gpx_fit_file_parse_field (GpxFitFile* self, GpxFitFileFieldDefinitionHeader* field, GDataInputStream* fp, GError** error);
static void gpx_fit_file_parse_data_record_lap (GpxFitFile* self, GDataInputStream* fs, GpxFitFileFieldDefinition* def, GError** error);
static void gpx_fit_file_parse_data_record_activity_summary (GpxFitFile* self, GDataInputStream* fs, GpxFitFileFieldDefinition* def, GError** error);
static GpxFitFileFieldDefinitionHeader* _vala_array_dup1 (GpxFitFileFieldDefinitionHeader* self, int length);
static void gpx_fit_file_finalize (GObject* obj);


static GType gpx_fit_file_fit_types_get_type (void) {
	static volatile gsize gpx_fit_file_fit_types_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_fit_file_fit_types_type_id__volatile)) {
		static const GEnumValue values[] = {{GPX_FIT_FILE_FIT_TYPES_LAP, "GPX_FIT_FILE_FIT_TYPES_LAP", "lap"}, {GPX_FIT_FILE_FIT_TYPES_ACTIVITY_SUMMARY, "GPX_FIT_FILE_FIT_TYPES_ACTIVITY_SUMMARY", "activity-summary"}, {0, NULL, NULL}};
		GType gpx_fit_file_fit_types_type_id;
		gpx_fit_file_fit_types_type_id = g_enum_register_static ("GpxFitFileFitTypes", values);
		g_once_init_leave (&gpx_fit_file_fit_types_type_id__volatile, gpx_fit_file_fit_types_type_id);
	}
	return gpx_fit_file_fit_types_type_id__volatile;
}


static void _vala_GpxFitFileFieldDefinition_array_free (GpxFitFileFieldDefinition* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			gpx_fit_file_field_definition_destroy (&array[i]);
		}
	}
	g_free (array);
}


/**
         * Get the field description belonging to the id.
         */
static GpxFitFileFieldDefinition* gpx_fit_file_get_field_def (GpxFitFile* self, guint id) {
	GpxFitFileFieldDefinition* result = NULL;
	guint _tmp0_ = 0U;
	GpxFitFileFieldDefinition* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	guint _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = id;
	if (_tmp0_ >= ((guint) MAX_LOCAL_DEFINITIONS)) {
		g_error ("fit-parser.vala:54: To many local definitions specified.");
	}
	_tmp1_ = self->priv->defs;
	_tmp1__length1 = self->priv->defs_length1;
	_tmp2_ = id;
	result = &_tmp1_[_tmp2_];
	return result;
}


/**
         * Depending on the definition, switch endianess
         */
static void gpx_fit_file_parse_apply_definition_endian (GpxFitFile* self, GDataInputStream* fs, GpxFitFileFieldDefinition* def) {
	GpxFitFileFieldDefinition* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fs != NULL);
	_tmp0_ = def;
	_tmp1_ = (*_tmp0_).endian;
	if (_tmp1_) {
		GDataInputStream* _tmp2_ = NULL;
		_tmp2_ = fs;
		g_data_input_stream_set_byte_order (_tmp2_, G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN);
	} else {
		GDataInputStream* _tmp3_ = NULL;
		_tmp3_ = fs;
		g_data_input_stream_set_byte_order (_tmp3_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
	}
}


/**
         * Parse the file.
         */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _g_error_copy0 (gpointer self) {
	return self ? g_error_copy (self) : NULL;
}


GpxFitFile* gpx_fit_file_construct (GType object_type, GFile* file, GError** error) {
	GpxFitFile * self = NULL;
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (file != NULL, NULL);
	self = (GpxFitFile*) gpx_file_base_construct (object_type);
	_tmp0_ = file;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (((GpxFileBase*) self)->file);
	((GpxFileBase*) self)->file = _tmp1_;
	{
		GFileInputStream* istr = NULL;
		GFile* _tmp2_ = NULL;
		GFileInputStream* _tmp3_ = NULL;
		GDataInputStream* fs = NULL;
		GFileInputStream* _tmp4_ = NULL;
		GDataInputStream* _tmp5_ = NULL;
		GDataInputStream* _tmp6_ = NULL;
		GDataInputStream* _tmp8_ = NULL;
		GDataStreamByteOrder _tmp9_ = 0;
		GDataInputStream* _tmp11_ = NULL;
		GpxTrack* _tmp14_ = NULL;
		_tmp2_ = file;
		_tmp3_ = g_file_read (_tmp2_, NULL, &_inner_error_);
		istr = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch3_g_io_error;
			}
			goto __catch3_g_error;
		}
		_tmp4_ = istr;
		_tmp5_ = g_data_input_stream_new ((GInputStream*) _tmp4_);
		fs = _tmp5_;
		_tmp6_ = fs;
		if (_tmp6_ == NULL) {
			GError* _tmp7_ = NULL;
			_tmp7_ = g_error_new_literal (GPX_FILE_ERROR, GPX_FILE_ERROR_IO_ERROR, "Failed to create input stream.");
			_inner_error_ = _tmp7_;
			_g_object_unref0 (fs);
			_g_object_unref0 (istr);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch3_g_io_error;
			}
			goto __catch3_g_error;
		}
		_tmp8_ = fs;
		_tmp9_ = g_data_input_stream_get_byte_order (_tmp8_);
		if (_tmp9_ != G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN) {
			GDataInputStream* _tmp10_ = NULL;
			_tmp10_ = fs;
			g_data_input_stream_set_byte_order (_tmp10_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
		}
		_tmp11_ = fs;
		gpx_fit_file_parse_header (self, _tmp11_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (fs);
			_g_object_unref0 (istr);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch3_g_io_error;
			}
			goto __catch3_g_error;
		}
		while (TRUE) {
			GDataInputStream* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			_tmp12_ = fs;
			_tmp13_ = gpx_fit_file_parse_record (self, _tmp12_);
			if (!_tmp13_) {
				break;
			}
		}
		_tmp14_ = self->priv->track;
		if (_tmp14_ != NULL) {
			GpxTrack* _tmp15_ = NULL;
			GpxTrack* _tmp16_ = NULL;
			GpxTrack* _tmp17_ = NULL;
			_tmp15_ = self->priv->track;
			gpx_track_filter_points (_tmp15_);
			_tmp16_ = self->priv->track;
			_tmp17_ = _g_object_ref0 (_tmp16_);
			((GpxFileBase*) self)->tracks = g_list_append (((GpxFileBase*) self)->tracks, _tmp17_);
		}
		_g_object_unref0 (fs);
		_g_object_unref0 (istr);
	}
	goto __finally3;
	__catch3_g_io_error:
	{
		GError* err = NULL;
		GError* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		GError* _tmp20_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp18_ = err;
		_tmp19_ = _tmp18_->message;
		_tmp20_ = g_error_new_literal (GPX_FILE_ERROR, GPX_FILE_ERROR_IO_ERROR, _tmp19_);
		_inner_error_ = _tmp20_;
		_g_error_free0 (err);
		goto __finally3;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* err = NULL;
		GError* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		GError* _tmp23_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp21_ = err;
		_tmp22_ = _tmp21_->message;
		_tmp23_ = g_error_new_literal (GPX_FILE_ERROR, GPX_FILE_ERROR_IO_ERROR, _tmp22_);
		_inner_error_ = _tmp23_;
		_g_error_free0 (err);
		goto __finally3;
	}
	goto __finally3;
	__catch3_gpx_file_error:
	{
		GError* err = NULL;
		GError* _tmp24_ = NULL;
		GError* _tmp25_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp24_ = err;
		_tmp25_ = _g_error_copy0 (_tmp24_);
		_inner_error_ = _tmp25_;
		_g_error_free0 (err);
		goto __finally3;
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == GPX_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	return self;
}


GpxFitFile* gpx_fit_file_new (GFile* file, GError** error) {
	return gpx_fit_file_construct (GPX_TYPE_FIT_FILE, file, error);
}


/**
         * Parse record
         */
static gboolean gpx_fit_file_parse_record (GpxFitFile* self, GDataInputStream* fs) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (fs != NULL, FALSE);
	{
		guint32 _tmp0_ = 0U;
		guint8 record_id = 0U;
		GDataInputStream* _tmp1_ = NULL;
		guint8 _tmp2_ = 0U;
		guint32 _tmp3_ = 0U;
		gboolean normal_header = FALSE;
		guint8 _tmp4_ = 0U;
		gboolean definition_header = FALSE;
		guint8 local_message_type = 0U;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp9_ = FALSE;
		_tmp0_ = self->priv->data_length;
		if (_tmp0_ == ((guint32) 0)) {
			result = FALSE;
			return result;
		}
		_tmp1_ = fs;
		_tmp2_ = g_data_input_stream_read_byte (_tmp1_, NULL, &_inner_error_);
		record_id = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
		_tmp3_ = self->priv->data_length;
		self->priv->data_length = _tmp3_ - 1;
		_tmp4_ = record_id;
		normal_header = ((gint) (_tmp4_ & 0x80)) == 0;
		_tmp5_ = normal_header;
		if (_tmp5_) {
			guint8 _tmp6_ = 0U;
			guint8 _tmp7_ = 0U;
			_tmp6_ = record_id;
			definition_header = ((gint) (_tmp6_ & 0x40)) > 0;
			_tmp7_ = record_id;
			local_message_type = _tmp7_ & 0x0F;
		} else {
			guint8 _tmp8_ = 0U;
			definition_header = FALSE;
			_tmp8_ = record_id;
			local_message_type = (guint8) ((_tmp8_ & 0x60) >> 5);
		}
		_tmp9_ = definition_header;
		if (_tmp9_) {
			GDataInputStream* _tmp10_ = NULL;
			guint8 _tmp11_ = 0U;
			_tmp10_ = fs;
			_tmp11_ = local_message_type;
			gpx_fit_file_parse_definition_record (self, _tmp10_, _tmp11_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch4_g_error;
			}
		} else {
			GDataInputStream* _tmp12_ = NULL;
			guint8 _tmp13_ = 0U;
			_tmp12_ = fs;
			_tmp13_ = local_message_type;
			gpx_fit_file_parse_data_record (self, _tmp12_, _tmp13_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch4_g_error;
			}
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


static void gpx_fit_file_parse_definition_record (GpxFitFile* self, GDataInputStream* fs, guint8 local_message_type, GError** error) {
	GpxFitFileFieldDefinition* def = NULL;
	guint8 _tmp0_ = 0U;
	GpxFitFileFieldDefinition* _tmp1_ = NULL;
	GDataInputStream* _tmp2_ = NULL;
	guint32 _tmp3_ = 0U;
	guint8 endian = 0U;
	GDataInputStream* _tmp4_ = NULL;
	guint8 _tmp5_ = 0U;
	guint32 _tmp6_ = 0U;
	guint8 _tmp7_ = 0U;
	GDataInputStream* _tmp8_ = NULL;
	GpxFitFileFieldDefinition* _tmp9_ = NULL;
	guint16 _tmp10_ = 0U;
	GDataInputStream* _tmp11_ = NULL;
	guint16 _tmp12_ = 0U;
	guint32 _tmp13_ = 0U;
	guint8 num_fields = 0U;
	GDataInputStream* _tmp14_ = NULL;
	guint8 _tmp15_ = 0U;
	guint32 _tmp16_ = 0U;
	guint8 _tmp17_ = 0U;
	GpxFitFileFieldDefinitionHeader* _tmp18_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fs != NULL);
	_tmp0_ = local_message_type;
	_tmp1_ = gpx_fit_file_get_field_def (self, (guint) _tmp0_);
	def = _tmp1_;
	_tmp2_ = fs;
	g_input_stream_skip ((GInputStream*) _tmp2_, (gsize) 1, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp3_ = self->priv->data_length;
	self->priv->data_length = _tmp3_ - 1;
	_tmp4_ = fs;
	_tmp5_ = g_data_input_stream_read_byte (_tmp4_, NULL, &_inner_error_);
	endian = _tmp5_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp6_ = self->priv->data_length;
	self->priv->data_length = _tmp6_ - 1;
	_tmp7_ = endian;
	if (((gint) _tmp7_) == 1) {
		(*def).endian = TRUE;
	} else {
		(*def).endian = FALSE;
	}
	_tmp8_ = fs;
	_tmp9_ = def;
	gpx_fit_file_parse_apply_definition_endian (self, _tmp8_, _tmp9_);
	_tmp11_ = fs;
	_tmp12_ = g_data_input_stream_read_uint16 (_tmp11_, NULL, &_inner_error_);
	_tmp10_ = _tmp12_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	(*def).type = _tmp10_;
	_tmp13_ = self->priv->data_length;
	self->priv->data_length = _tmp13_ - 2;
	_tmp14_ = fs;
	_tmp15_ = g_data_input_stream_read_byte (_tmp14_, NULL, &_inner_error_);
	num_fields = _tmp15_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp16_ = self->priv->data_length;
	self->priv->data_length = _tmp16_ - 1;
	_tmp17_ = num_fields;
	_tmp18_ = g_new0 (GpxFitFileFieldDefinitionHeader, _tmp17_);
	(*def).fields = (g_free ((*def).fields), NULL);
	(*def).fields = _tmp18_;
	(*def).fields_length1 = _tmp17_;
	(*def)._fields_size_ = (*def).fields_length1;
	{
		guint8 field = 0U;
		field = (guint8) 0;
		{
			gboolean _tmp19_ = FALSE;
			_tmp19_ = TRUE;
			while (TRUE) {
				guint8 _tmp21_ = 0U;
				guint8 _tmp22_ = 0U;
				GpxFitFileFieldDefinitionHeader* header = NULL;
				guint8* temp = NULL;
				guint8* _tmp23_ = NULL;
				gint temp_length1 = 0;
				gint _temp_size_ = 0;
				GDataInputStream* _tmp24_ = NULL;
				guint8* _tmp25_ = NULL;
				gint _tmp25__length1 = 0;
				guint8* _tmp26_ = NULL;
				gint _tmp26__length1 = 0;
				GpxFitFileFieldDefinition* _tmp27_ = NULL;
				GpxFitFileFieldDefinitionHeader* _tmp28_ = NULL;
				gint _tmp28__length1 = 0;
				guint8 _tmp29_ = 0U;
				GpxFitFileFieldDefinitionHeader* _tmp30_ = NULL;
				GpxFitFileFieldDefinitionHeader _tmp31_ = {0};
				guint32 _tmp32_ = 0U;
				if (!_tmp19_) {
					guint8 _tmp20_ = 0U;
					_tmp20_ = field;
					field = _tmp20_ + 1;
				}
				_tmp19_ = FALSE;
				_tmp21_ = field;
				_tmp22_ = num_fields;
				if (!(_tmp21_ < _tmp22_)) {
					break;
				}
				_tmp23_ = g_new0 (guint8, sizeof (GpxFitFileFieldDefinitionHeader));
				temp = _tmp23_;
				temp_length1 = sizeof (GpxFitFileFieldDefinitionHeader);
				_temp_size_ = temp_length1;
				_tmp24_ = fs;
				_tmp25_ = temp;
				_tmp25__length1 = temp_length1;
				g_input_stream_read ((GInputStream*) _tmp24_, _tmp25_, (gsize) _tmp25__length1, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
						g_propagate_error (error, _inner_error_);
						temp = (g_free (temp), NULL);
						return;
					} else {
						temp = (g_free (temp), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_tmp26_ = temp;
				_tmp26__length1 = temp_length1;
				header = (GpxFitFileFieldDefinitionHeader*) (&_tmp26_[0]);
				_tmp27_ = def;
				_tmp28_ = (*_tmp27_).fields;
				_tmp28__length1 = (*_tmp27_).fields_length1;
				_tmp29_ = field;
				_tmp30_ = header;
				_tmp28_[_tmp29_] = *_tmp30_;
				_tmp31_ = _tmp28_[_tmp29_];
				_tmp32_ = self->priv->data_length;
				self->priv->data_length = _tmp32_ - ((guint32) sizeof (GpxFitFileFieldDefinitionHeader));
				temp = (g_free (temp), NULL);
			}
		}
	}
}


static guint32 gpx_fit_file_parse_field (GpxFitFile* self, GpxFitFileFieldDefinitionHeader* field, GDataInputStream* fp, GError** error) {
	guint32 result = 0U;
	guint32 retv = 0U;
	GpxFitFileFieldDefinitionHeader _tmp0_ = {0};
	guint8 _tmp1_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0U);
	g_return_val_if_fail (field != NULL, 0U);
	g_return_val_if_fail (fp != NULL, 0U);
	retv = (guint32) 0;
	_tmp0_ = *field;
	_tmp1_ = _tmp0_.base_type;
	switch (_tmp1_) {
		case 1:
		case 2:
		{
			guint8 _tmp2_ = 0U;
			GDataInputStream* _tmp3_ = NULL;
			guint8 _tmp4_ = 0U;
			guint32 _tmp5_ = 0U;
			_tmp3_ = fp;
			_tmp4_ = g_data_input_stream_read_byte (_tmp3_, NULL, &_inner_error_);
			_tmp2_ = _tmp4_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return 0U;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0U;
				}
			}
			retv = (guint32) _tmp2_;
			_tmp5_ = self->priv->data_length;
			self->priv->data_length = _tmp5_ - 1;
			break;
		}
		case 0x83:
		case 0x84:
		{
			guint16 _tmp6_ = 0U;
			GDataInputStream* _tmp7_ = NULL;
			guint16 _tmp8_ = 0U;
			guint32 _tmp9_ = 0U;
			_tmp7_ = fp;
			_tmp8_ = g_data_input_stream_read_uint16 (_tmp7_, NULL, &_inner_error_);
			_tmp6_ = _tmp8_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return 0U;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0U;
				}
			}
			retv = (guint32) _tmp6_;
			_tmp9_ = self->priv->data_length;
			self->priv->data_length = _tmp9_ - 2;
			break;
		}
		case 0x85:
		case 0x86:
		{
			guint32 _tmp10_ = 0U;
			GDataInputStream* _tmp11_ = NULL;
			guint32 _tmp12_ = 0U;
			guint32 _tmp13_ = 0U;
			_tmp11_ = fp;
			_tmp12_ = g_data_input_stream_read_uint32 (_tmp11_, NULL, &_inner_error_);
			_tmp10_ = _tmp12_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return 0U;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0U;
				}
			}
			retv = _tmp10_;
			_tmp13_ = self->priv->data_length;
			self->priv->data_length = _tmp13_ - 4;
			break;
		}
		default:
		{
			GDataInputStream* _tmp14_ = NULL;
			GpxFitFileFieldDefinitionHeader _tmp15_ = {0};
			guint8 _tmp16_ = 0U;
			guint32 _tmp17_ = 0U;
			GpxFitFileFieldDefinitionHeader _tmp18_ = {0};
			guint8 _tmp19_ = 0U;
			_tmp14_ = fp;
			_tmp15_ = *field;
			_tmp16_ = _tmp15_.size;
			g_input_stream_skip ((GInputStream*) _tmp14_, (gsize) _tmp16_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return 0U;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0U;
				}
			}
			_tmp17_ = self->priv->data_length;
			_tmp18_ = *field;
			_tmp19_ = _tmp18_.size;
			self->priv->data_length = _tmp17_ - _tmp19_;
			break;
		}
	}
	result = retv;
	return result;
}


static void gpx_fit_file_parse_data_record_lap (GpxFitFile* self, GDataInputStream* fs, GpxFitFileFieldDefinition* def, GError** error) {
	GpxFitFileFieldDefinition* _tmp0_ = NULL;
	GpxFitFileFieldDefinitionHeader* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	GpxTrack* _tmp22_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fs != NULL);
	_tmp0_ = def;
	_tmp1_ = (*_tmp0_).fields;
	_tmp1__length1 = (*_tmp0_).fields_length1;
	{
		GpxFitFileFieldDefinitionHeader* field_collection = NULL;
		gint field_collection_length1 = 0;
		gint _field_collection_size_ = 0;
		gint field_it = 0;
		field_collection = _tmp1_;
		field_collection_length1 = _tmp1__length1;
		for (field_it = 0; field_it < _tmp1__length1; field_it = field_it + 1) {
			GpxFitFileFieldDefinitionHeader field = {0};
			field = field_collection[field_it];
			{
				GpxFitFileFieldDefinitionHeader _tmp2_ = {0};
				guint8 _tmp3_ = 0U;
				_tmp2_ = field;
				_tmp3_ = _tmp2_.def_num;
				switch (_tmp3_) {
					case 11:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp4_ = {0};
						GDataInputStream* _tmp5_ = NULL;
						guint32 _tmp6_ = 0U;
						GpxTrack* _tmp7_ = NULL;
						guint32 _tmp8_ = 0U;
						_tmp4_ = field;
						_tmp5_ = fs;
						_tmp6_ = gpx_fit_file_parse_field (self, &_tmp4_, _tmp5_, &_inner_error_);
						val = _tmp6_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								return;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp7_ = self->priv->track;
						_tmp8_ = val;
						_tmp7_->hrmt.calories = _tmp8_;
						break;
					}
					case 15:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp9_ = {0};
						GDataInputStream* _tmp10_ = NULL;
						guint32 _tmp11_ = 0U;
						_tmp9_ = field;
						_tmp10_ = fs;
						_tmp11_ = gpx_fit_file_parse_field (self, &_tmp9_, _tmp10_, &_inner_error_);
						val = _tmp11_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								return;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						break;
					}
					case 16:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp12_ = {0};
						GDataInputStream* _tmp13_ = NULL;
						guint32 _tmp14_ = 0U;
						_tmp12_ = field;
						_tmp13_ = fs;
						_tmp14_ = gpx_fit_file_parse_field (self, &_tmp12_, _tmp13_, &_inner_error_);
						val = _tmp14_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								return;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						break;
					}
					default:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp15_ = {0};
						GDataInputStream* _tmp16_ = NULL;
						guint32 _tmp17_ = 0U;
						FILE* _tmp18_ = NULL;
						GpxFitFileFieldDefinitionHeader _tmp19_ = {0};
						guint8 _tmp20_ = 0U;
						guint32 _tmp21_ = 0U;
						_tmp15_ = field;
						_tmp16_ = fs;
						_tmp17_ = gpx_fit_file_parse_field (self, &_tmp15_, _tmp16_, &_inner_error_);
						val = _tmp17_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								return;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp18_ = stdout;
						_tmp19_ = field;
						_tmp20_ = _tmp19_.def_num;
						_tmp21_ = val;
						fprintf (_tmp18_, "%d %u\n", (gint) _tmp20_, (guint) _tmp21_);
						break;
					}
				}
			}
		}
	}
	_tmp22_ = self->priv->track;
	if (_tmp22_ != NULL) {
		GpxTrack* _tmp23_ = NULL;
		GpxTrack* _tmp24_ = NULL;
		GpxTrack* _tmp25_ = NULL;
		_tmp23_ = self->priv->track;
		gpx_track_filter_points (_tmp23_);
		_tmp24_ = self->priv->track;
		_tmp25_ = _g_object_ref0 (_tmp24_);
		((GpxFileBase*) self)->tracks = g_list_append (((GpxFileBase*) self)->tracks, _tmp25_);
		_g_object_unref0 (self->priv->track);
		self->priv->track = NULL;
	}
}


static void g_time_local (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	localtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


static gchar* g_time_format (struct tm *self, const gchar* format) {
	gchar* result = NULL;
	gchar* buffer = NULL;
	gchar* _tmp0_ = NULL;
	gint buffer_length1 = 0;
	gint _buffer_size_ = 0;
	gchar* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (format != NULL, NULL);
	_tmp0_ = g_new0 (gchar, 64);
	buffer = _tmp0_;
	buffer_length1 = 64;
	_buffer_size_ = buffer_length1;
	_tmp1_ = buffer;
	_tmp1__length1 = buffer_length1;
	_tmp2_ = format;
	strftime (_tmp1_, _tmp1__length1, _tmp2_, &(*self));
	_tmp3_ = buffer;
	_tmp3__length1 = buffer_length1;
	_tmp4_ = g_strdup ((const gchar*) _tmp3_);
	result = _tmp4_;
	buffer = (g_free (buffer), NULL);
	return result;
}


static gpointer _gpx_point_ref0 (gpointer self) {
	return self ? gpx_point_ref (self) : NULL;
}


static void gpx_fit_file_parse_data_record_activity_summary (GpxFitFile* self, GDataInputStream* fs, GpxFitFileFieldDefinition* def, GError** error) {
	GpxTrack* _tmp0_ = NULL;
	GpxPoint* p = NULL;
	GpxPoint* _tmp2_ = NULL;
	GpxFitFileFieldDefinition* _tmp3_ = NULL;
	GpxFitFileFieldDefinitionHeader* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	GpxPoint* lastp = NULL;
	GpxTrack* _tmp63_ = NULL;
	GpxPoint* _tmp64_ = NULL;
	GpxPoint* _tmp65_ = NULL;
	gboolean _tmp66_ = FALSE;
	GpxPoint* _tmp67_ = NULL;
	GpxPoint* _tmp72_ = NULL;
	gboolean _tmp73_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fs != NULL);
	_tmp0_ = self->priv->track;
	if (_tmp0_ == NULL) {
		GpxTrack* _tmp1_ = NULL;
		_tmp1_ = gpx_track_new ();
		_g_object_unref0 (self->priv->track);
		self->priv->track = _tmp1_;
	}
	_tmp2_ = gpx_point_new ();
	p = _tmp2_;
	_tmp3_ = def;
	_tmp4_ = (*_tmp3_).fields;
	_tmp4__length1 = (*_tmp3_).fields_length1;
	{
		GpxFitFileFieldDefinitionHeader* field_collection = NULL;
		gint field_collection_length1 = 0;
		gint _field_collection_size_ = 0;
		gint field_it = 0;
		field_collection = _tmp4_;
		field_collection_length1 = _tmp4__length1;
		for (field_it = 0; field_it < _tmp4__length1; field_it = field_it + 1) {
			GpxFitFileFieldDefinitionHeader field = {0};
			field = field_collection[field_it];
			{
				GpxFitFileFieldDefinitionHeader _tmp5_ = {0};
				guint8 _tmp6_ = 0U;
				_tmp5_ = field;
				_tmp6_ = _tmp5_.def_num;
				switch (_tmp6_) {
					case 253:
					{
						guint32 timestp = 0U;
						GpxFitFileFieldDefinitionHeader _tmp7_ = {0};
						GDataInputStream* _tmp8_ = NULL;
						guint32 _tmp9_ = 0U;
						guint32 _tmp10_ = 0U;
						struct tm t = {0};
						guint32 _tmp11_ = 0U;
						struct tm _tmp12_ = {0};
						gchar* str = NULL;
						gchar* _tmp13_ = NULL;
						GpxPoint* _tmp14_ = NULL;
						const gchar* _tmp15_ = NULL;
						gchar* _tmp16_ = NULL;
						_tmp7_ = field;
						_tmp8_ = fs;
						_tmp9_ = gpx_fit_file_parse_field (self, &_tmp7_, _tmp8_, &_inner_error_);
						timestp = _tmp9_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp10_ = timestp;
						timestp = _tmp10_ + 631065600;
						_tmp11_ = timestp;
						g_time_local ((time_t) _tmp11_, &_tmp12_);
						t = _tmp12_;
						_tmp13_ = g_time_format (&t, "%FT%T%z");
						str = _tmp13_;
						_tmp14_ = p;
						_tmp15_ = str;
						_tmp16_ = g_strdup (_tmp15_);
						_g_free0 (_tmp14_->time);
						_tmp14_->time = _tmp16_;
						_g_free0 (str);
						break;
					}
					case 0:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp17_ = {0};
						GDataInputStream* _tmp18_ = NULL;
						guint32 _tmp19_ = 0U;
						guint32 _tmp20_ = 0U;
						_tmp17_ = field;
						_tmp18_ = fs;
						_tmp19_ = gpx_fit_file_parse_field (self, &_tmp17_, _tmp18_, &_inner_error_);
						val = _tmp19_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp20_ = val;
						if (_tmp20_ != ((guint32) 0x7FFFFFFF)) {
							gdouble lat_dec = 0.0;
							guint32 _tmp21_ = 0U;
							gdouble _tmp22_ = 0.0;
							GpxPoint* _tmp23_ = NULL;
							gdouble _tmp24_ = 0.0;
							_tmp21_ = val;
							_tmp22_ = pow (2.0, 31.0);
							lat_dec = ((gdouble) _tmp21_) * (180.0 / _tmp22_);
							_tmp23_ = p;
							_tmp24_ = lat_dec;
							gpx_point_set_position_lat (_tmp23_, _tmp24_);
						}
						break;
					}
					case 1:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp25_ = {0};
						GDataInputStream* _tmp26_ = NULL;
						guint32 _tmp27_ = 0U;
						guint32 _tmp28_ = 0U;
						_tmp25_ = field;
						_tmp26_ = fs;
						_tmp27_ = gpx_fit_file_parse_field (self, &_tmp25_, _tmp26_, &_inner_error_);
						val = _tmp27_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp28_ = val;
						if (_tmp28_ != ((guint32) 0x7FFFFFFF)) {
							gdouble lon_dec = 0.0;
							guint32 _tmp29_ = 0U;
							gdouble _tmp30_ = 0.0;
							GpxPoint* _tmp31_ = NULL;
							gdouble _tmp32_ = 0.0;
							_tmp29_ = val;
							_tmp30_ = pow (2.0, 31.0);
							lon_dec = ((gdouble) _tmp29_) * (180.0 / _tmp30_);
							_tmp31_ = p;
							_tmp32_ = lon_dec;
							gpx_point_set_position_lon (_tmp31_, _tmp32_);
						}
						break;
					}
					case 2:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp33_ = {0};
						GDataInputStream* _tmp34_ = NULL;
						guint32 _tmp35_ = 0U;
						guint32 _tmp36_ = 0U;
						_tmp33_ = field;
						_tmp34_ = fs;
						_tmp35_ = gpx_fit_file_parse_field (self, &_tmp33_, _tmp34_, &_inner_error_);
						val = _tmp35_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp36_ = val;
						if (_tmp36_ != ((guint32) 0xFFFF)) {
							GpxPoint* _tmp37_ = NULL;
							guint32 _tmp38_ = 0U;
							_tmp37_ = p;
							_tmp38_ = val;
							_tmp37_->elevation = (_tmp38_ / 5.0) - 500;
						}
						break;
					}
					case 3:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp39_ = {0};
						GDataInputStream* _tmp40_ = NULL;
						guint32 _tmp41_ = 0U;
						guint32 _tmp42_ = 0U;
						_tmp39_ = field;
						_tmp40_ = fs;
						_tmp41_ = gpx_fit_file_parse_field (self, &_tmp39_, _tmp40_, &_inner_error_);
						val = _tmp41_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp42_ = val;
						if (_tmp42_ != ((guint32) 0xFF)) {
							GpxPoint* _tmp43_ = NULL;
							guint32 _tmp44_ = 0U;
							_tmp43_ = p;
							_tmp44_ = val;
							_tmp43_->tpe.heartrate = (gint) _tmp44_;
						}
						break;
					}
					case 4:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp45_ = {0};
						GDataInputStream* _tmp46_ = NULL;
						guint32 _tmp47_ = 0U;
						guint32 _tmp48_ = 0U;
						_tmp45_ = field;
						_tmp46_ = fs;
						_tmp47_ = gpx_fit_file_parse_field (self, &_tmp45_, _tmp46_, &_inner_error_);
						val = _tmp47_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp48_ = val;
						if (_tmp48_ != ((guint32) 0xFF)) {
							GpxPoint* _tmp49_ = NULL;
							guint32 _tmp50_ = 0U;
							_tmp49_ = p;
							_tmp50_ = val;
							_tmp49_->cadence = _tmp50_;
						}
						break;
					}
					case 18:
					{
						guint32 val = 0U;
						GpxFitFileFieldDefinitionHeader _tmp51_ = {0};
						GDataInputStream* _tmp52_ = NULL;
						guint32 _tmp53_ = 0U;
						guint32 _tmp54_ = 0U;
						_tmp51_ = field;
						_tmp52_ = fs;
						_tmp53_ = gpx_fit_file_parse_field (self, &_tmp51_, _tmp52_, &_inner_error_);
						val = _tmp53_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp54_ = val;
						if (_tmp54_ != ((guint32) 0xFF)) {
							FILE* _tmp55_ = NULL;
							guint32 _tmp56_ = 0U;
							_tmp55_ = stdout;
							_tmp56_ = val;
							fprintf (_tmp55_, "Cycles: %u\n", (guint) _tmp56_);
						}
						break;
					}
					default:
					{
						GDataInputStream* _tmp57_ = NULL;
						GpxFitFileFieldDefinitionHeader _tmp58_ = {0};
						guint8 _tmp59_ = 0U;
						guint32 _tmp60_ = 0U;
						GpxFitFileFieldDefinitionHeader _tmp61_ = {0};
						guint8 _tmp62_ = 0U;
						_tmp57_ = fs;
						_tmp58_ = field;
						_tmp59_ = _tmp58_.size;
						g_input_stream_skip ((GInputStream*) _tmp57_, (gsize) _tmp59_, NULL, &_inner_error_);
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								_gpx_point_unref0 (p);
								return;
							} else {
								_gpx_point_unref0 (p);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp60_ = self->priv->data_length;
						_tmp61_ = field;
						_tmp62_ = _tmp61_.size;
						self->priv->data_length = _tmp60_ - _tmp62_;
						break;
					}
				}
			}
		}
	}
	_tmp63_ = self->priv->track;
	_tmp64_ = gpx_track_get_last (_tmp63_);
	_tmp65_ = _gpx_point_ref0 (_tmp64_);
	lastp = _tmp65_;
	_tmp67_ = lastp;
	if (_tmp67_ != NULL) {
		GpxPoint* _tmp68_ = NULL;
		time_t _tmp69_ = 0;
		GpxPoint* _tmp70_ = NULL;
		time_t _tmp71_ = 0;
		_tmp68_ = lastp;
		_tmp69_ = gpx_point_get_time (_tmp68_);
		_tmp70_ = p;
		_tmp71_ = gpx_point_get_time (_tmp70_);
		_tmp66_ = _tmp69_ == _tmp71_;
	} else {
		_tmp66_ = FALSE;
	}
	if (_tmp66_) {
		_gpx_point_unref0 (lastp);
		_gpx_point_unref0 (p);
		return;
	}
	_tmp72_ = p;
	_tmp73_ = gpx_point_has_position (_tmp72_);
	if (_tmp73_) {
		gboolean _tmp74_ = FALSE;
		GpxPoint* _tmp75_ = NULL;
		GpxTrack* _tmp103_ = NULL;
		GpxPoint* _tmp104_ = NULL;
		_tmp75_ = lastp;
		if (_tmp75_ != NULL) {
			GpxPoint* _tmp76_ = NULL;
			gboolean _tmp77_ = FALSE;
			_tmp76_ = lastp;
			_tmp77_ = gpx_point_has_position (_tmp76_);
			_tmp74_ = !_tmp77_;
		} else {
			_tmp74_ = FALSE;
		}
		if (_tmp74_) {
			GList* ll = NULL;
			GpxTrack* _tmp78_ = NULL;
			GList* _tmp79_ = NULL;
			GList* _tmp80_ = NULL;
			_tmp78_ = self->priv->track;
			_tmp79_ = _tmp78_->points;
			_tmp80_ = g_list_last (_tmp79_);
			ll = _tmp80_;
			while (TRUE) {
				gboolean _tmp81_ = FALSE;
				GList* _tmp82_ = NULL;
				GpxPoint* last = NULL;
				GList* _tmp86_ = NULL;
				gconstpointer _tmp87_ = NULL;
				GpxPoint* _tmp88_ = NULL;
				GpxPoint* _tmp89_ = NULL;
				GpxPoint* _tmp90_ = NULL;
				gdouble _tmp91_ = 0.0;
				GpxPoint* _tmp92_ = NULL;
				GpxPoint* _tmp93_ = NULL;
				gdouble _tmp94_ = 0.0;
				GpxPoint* _tmp95_ = NULL;
				GpxPoint* _tmp96_ = NULL;
				gdouble _tmp97_ = 0.0;
				GpxPoint* _tmp98_ = NULL;
				GpxPoint* _tmp99_ = NULL;
				gdouble _tmp100_ = 0.0;
				GList* _tmp101_ = NULL;
				GList* _tmp102_ = NULL;
				_tmp82_ = ll;
				if (_tmp82_ != NULL) {
					GList* _tmp83_ = NULL;
					gconstpointer _tmp84_ = NULL;
					gboolean _tmp85_ = FALSE;
					_tmp83_ = ll;
					_tmp84_ = _tmp83_->data;
					_tmp85_ = gpx_point_has_position ((GpxPoint*) _tmp84_);
					_tmp81_ = !_tmp85_;
				} else {
					_tmp81_ = FALSE;
				}
				if (!_tmp81_) {
					break;
				}
				_tmp86_ = ll;
				_tmp87_ = _tmp86_->data;
				_tmp88_ = _gpx_point_ref0 ((GpxPoint*) _tmp87_);
				last = _tmp88_;
				_tmp89_ = last;
				_tmp90_ = p;
				_tmp91_ = _tmp90_->lat_dec;
				_tmp89_->lat_dec = _tmp91_;
				_tmp92_ = last;
				_tmp93_ = p;
				_tmp94_ = _tmp93_->lon_dec;
				_tmp92_->lon_dec = _tmp94_;
				_tmp95_ = last;
				_tmp96_ = p;
				_tmp97_ = _tmp96_->lat;
				_tmp95_->lat = _tmp97_;
				_tmp98_ = last;
				_tmp99_ = p;
				_tmp100_ = _tmp99_->lon;
				_tmp98_->lon = _tmp100_;
				_tmp101_ = ll;
				_tmp102_ = _tmp101_->prev;
				ll = _tmp102_;
				_gpx_point_unref0 (last);
			}
		}
		_tmp103_ = self->priv->track;
		_tmp104_ = p;
		gpx_track_add_point (_tmp103_, _tmp104_);
	} else {
		GpxPoint* _tmp105_ = NULL;
		_tmp105_ = lastp;
		if (_tmp105_ != NULL) {
			GpxPoint* _tmp106_ = NULL;
			GpxPoint* _tmp107_ = NULL;
			gdouble _tmp108_ = 0.0;
			GpxPoint* _tmp109_ = NULL;
			GpxPoint* _tmp110_ = NULL;
			gdouble _tmp111_ = 0.0;
			GpxPoint* _tmp112_ = NULL;
			GpxPoint* _tmp113_ = NULL;
			gdouble _tmp114_ = 0.0;
			GpxPoint* _tmp115_ = NULL;
			GpxPoint* _tmp116_ = NULL;
			gdouble _tmp117_ = 0.0;
			GpxTrack* _tmp118_ = NULL;
			GpxPoint* _tmp119_ = NULL;
			_tmp106_ = p;
			_tmp107_ = lastp;
			_tmp108_ = _tmp107_->lat_dec;
			_tmp106_->lat_dec = _tmp108_;
			_tmp109_ = p;
			_tmp110_ = lastp;
			_tmp111_ = _tmp110_->lon_dec;
			_tmp109_->lon_dec = _tmp111_;
			_tmp112_ = p;
			_tmp113_ = lastp;
			_tmp114_ = _tmp113_->lat;
			_tmp112_->lat = _tmp114_;
			_tmp115_ = p;
			_tmp116_ = lastp;
			_tmp117_ = _tmp116_->lon;
			_tmp115_->lon = _tmp117_;
			_tmp118_ = self->priv->track;
			_tmp119_ = p;
			gpx_track_add_point (_tmp118_, _tmp119_);
		} else {
			GpxTrack* _tmp120_ = NULL;
			GpxPoint* _tmp121_ = NULL;
			_tmp120_ = self->priv->track;
			_tmp121_ = p;
			gpx_track_add_point (_tmp120_, _tmp121_);
		}
	}
	_gpx_point_unref0 (lastp);
	_gpx_point_unref0 (p);
}


static void gpx_fit_file_parse_data_record (GpxFitFile* self, GDataInputStream* fs, guint8 local_message_type, GError** error) {
	GpxFitFileFieldDefinition* def = NULL;
	guint8 _tmp0_ = 0U;
	GpxFitFileFieldDefinition* _tmp1_ = NULL;
	GDataInputStream* _tmp2_ = NULL;
	GpxFitFileFieldDefinition* _tmp3_ = NULL;
	GpxFitFileFieldDefinition* _tmp4_ = NULL;
	guint16 _tmp5_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fs != NULL);
	_tmp0_ = local_message_type;
	_tmp1_ = gpx_fit_file_get_field_def (self, (guint) _tmp0_);
	def = _tmp1_;
	_tmp2_ = fs;
	_tmp3_ = def;
	gpx_fit_file_parse_apply_definition_endian (self, _tmp2_, _tmp3_);
	_tmp4_ = def;
	_tmp5_ = (*_tmp4_).type;
	switch (_tmp5_) {
		case GPX_FIT_FILE_FIT_TYPES_ACTIVITY_SUMMARY:
		{
			GDataInputStream* _tmp6_ = NULL;
			GpxFitFileFieldDefinition* _tmp7_ = NULL;
			_tmp6_ = fs;
			_tmp7_ = def;
			gpx_fit_file_parse_data_record_activity_summary (self, _tmp6_, _tmp7_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			break;
		}
		case GPX_FIT_FILE_FIT_TYPES_LAP:
		{
			GDataInputStream* _tmp8_ = NULL;
			GpxFitFileFieldDefinition* _tmp9_ = NULL;
			_tmp8_ = fs;
			_tmp9_ = def;
			gpx_fit_file_parse_data_record_lap (self, _tmp8_, _tmp9_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			break;
		}
		default:
		{
			FILE* _tmp10_ = NULL;
			GpxFitFileFieldDefinition* _tmp11_ = NULL;
			guint16 _tmp12_ = 0U;
			GpxFitFileFieldDefinition* _tmp13_ = NULL;
			GpxFitFileFieldDefinitionHeader* _tmp14_ = NULL;
			gint _tmp14__length1 = 0;
			_tmp10_ = stdout;
			_tmp11_ = def;
			_tmp12_ = (*_tmp11_).type;
			fprintf (_tmp10_, "Unknown record: %d\n", (gint) _tmp12_);
			_tmp13_ = def;
			_tmp14_ = (*_tmp13_).fields;
			_tmp14__length1 = (*_tmp13_).fields_length1;
			{
				GpxFitFileFieldDefinitionHeader* field_collection = NULL;
				gint field_collection_length1 = 0;
				gint _field_collection_size_ = 0;
				gint field_it = 0;
				field_collection = _tmp14_;
				field_collection_length1 = _tmp14__length1;
				for (field_it = 0; field_it < _tmp14__length1; field_it = field_it + 1) {
					GpxFitFileFieldDefinitionHeader field = {0};
					field = field_collection[field_it];
					{
						GDataInputStream* _tmp15_ = NULL;
						GpxFitFileFieldDefinitionHeader _tmp16_ = {0};
						guint8 _tmp17_ = 0U;
						guint32 _tmp18_ = 0U;
						GpxFitFileFieldDefinitionHeader _tmp19_ = {0};
						guint8 _tmp20_ = 0U;
						_tmp15_ = fs;
						_tmp16_ = field;
						_tmp17_ = _tmp16_.size;
						g_input_stream_skip ((GInputStream*) _tmp15_, (gsize) _tmp17_, NULL, &_inner_error_);
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
								g_propagate_error (error, _inner_error_);
								return;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_tmp18_ = self->priv->data_length;
						_tmp19_ = field;
						_tmp20_ = _tmp19_.size;
						self->priv->data_length = _tmp18_ - _tmp20_;
					}
				}
			}
			break;
		}
	}
}


/**
         * Parse the header.
         */
static void gpx_fit_file_parse_header (GpxFitFile* self, GDataInputStream* fs, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fs != NULL);
	{
		guint8 _tmp0_ = 0U;
		GDataInputStream* _tmp1_ = NULL;
		guint8 _tmp2_ = 0U;
		guchar header_size = '\0';
		guchar _tmp3_ = '\0';
		gboolean _tmp5_ = FALSE;
		guchar _tmp6_ = '\0';
		guint8 _tmp9_ = 0U;
		GDataInputStream* _tmp10_ = NULL;
		guint8 _tmp11_ = 0U;
		guchar version = '\0';
		guchar low = '\0';
		guchar _tmp12_ = '\0';
		guchar high = '\0';
		guchar _tmp13_ = '\0';
		guint16 _tmp14_ = 0U;
		GDataInputStream* _tmp15_ = NULL;
		guint16 _tmp16_ = 0U;
		guint16 profver = 0U;
		guint32 _tmp17_ = 0U;
		GDataInputStream* _tmp18_ = NULL;
		guint32 _tmp19_ = 0U;
		guint8* signature = NULL;
		guint8* _tmp20_ = NULL;
		gint signature_length1 = 0;
		gint _signature_size_ = 0;
		gssize size = 0L;
		GDataInputStream* _tmp21_ = NULL;
		guint8* _tmp22_ = NULL;
		gint _tmp22__length1 = 0;
		gssize _tmp23_ = 0L;
		gssize _tmp24_ = 0L;
		guchar _tmp37_ = '\0';
		_tmp1_ = fs;
		_tmp2_ = g_data_input_stream_read_byte (_tmp1_, NULL, &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		header_size = (guchar) _tmp0_;
		_tmp3_ = header_size;
		if (((gint) _tmp3_) == EOF) {
			GError* _tmp4_ = NULL;
			_tmp4_ = g_error_new_literal (GPX_FILE_ERROR, GPX_FILE_ERROR_INVALID_FILE, "Empty header");
			_inner_error_ = _tmp4_;
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp6_ = header_size;
		if (((gint) _tmp6_) == 12) {
			_tmp5_ = TRUE;
		} else {
			guchar _tmp7_ = '\0';
			_tmp7_ = header_size;
			_tmp5_ = ((gint) _tmp7_) == 14;
		}
		if (!_tmp5_) {
			GError* _tmp8_ = NULL;
			_tmp8_ = g_error_new_literal (GPX_FILE_ERROR, GPX_FILE_ERROR_INVALID_FILE, "Unsupported FIT Header size");
			_inner_error_ = _tmp8_;
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp10_ = fs;
		_tmp11_ = g_data_input_stream_read_byte (_tmp10_, NULL, &_inner_error_);
		_tmp9_ = _tmp11_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		version = (guchar) _tmp9_;
		_tmp12_ = version;
		low = _tmp12_ & 0x0f;
		_tmp13_ = version;
		high = (guchar) ((_tmp13_ & 0xf0) >> 4);
		_tmp15_ = fs;
		_tmp16_ = g_data_input_stream_read_uint16 (_tmp15_, NULL, &_inner_error_);
		_tmp14_ = _tmp16_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		profver = (guint16) _tmp14_;
		_tmp18_ = fs;
		_tmp19_ = g_data_input_stream_read_uint32 (_tmp18_, NULL, &_inner_error_);
		_tmp17_ = _tmp19_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		self->priv->data_length = (guint32) _tmp17_;
		_tmp20_ = g_new0 (guint8, 4);
		_tmp20_[0] = (guint8) 0;
		_tmp20_[1] = (guint8) 0;
		_tmp20_[2] = (guint8) 0;
		_tmp20_[3] = (guint8) 0;
		signature = _tmp20_;
		signature_length1 = 4;
		_signature_size_ = signature_length1;
		_tmp21_ = fs;
		_tmp22_ = signature;
		_tmp22__length1 = signature_length1;
		_tmp23_ = g_input_stream_read ((GInputStream*) _tmp21_, _tmp22_, (gsize) _tmp22__length1, NULL, &_inner_error_);
		size = _tmp23_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			signature = (g_free (signature), NULL);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			if (_inner_error_->domain == GPX_FILE_ERROR) {
				goto __catch5_gpx_file_error;
			}
			signature = (g_free (signature), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp24_ = size;
		if (_tmp24_ == ((gssize) 4)) {
			gboolean _tmp25_ = FALSE;
			gboolean _tmp26_ = FALSE;
			gboolean _tmp27_ = FALSE;
			guint8* _tmp28_ = NULL;
			gint _tmp28__length1 = 0;
			guint8 _tmp29_ = 0U;
			_tmp28_ = signature;
			_tmp28__length1 = signature_length1;
			_tmp29_ = _tmp28_[0];
			if (_tmp29_ == ((guint8) '.')) {
				guint8* _tmp30_ = NULL;
				gint _tmp30__length1 = 0;
				guint8 _tmp31_ = 0U;
				_tmp30_ = signature;
				_tmp30__length1 = signature_length1;
				_tmp31_ = _tmp30_[1];
				_tmp27_ = _tmp31_ == ((guint8) 'F');
			} else {
				_tmp27_ = FALSE;
			}
			if (_tmp27_) {
				guint8* _tmp32_ = NULL;
				gint _tmp32__length1 = 0;
				guint8 _tmp33_ = 0U;
				_tmp32_ = signature;
				_tmp32__length1 = signature_length1;
				_tmp33_ = _tmp32_[2];
				_tmp26_ = _tmp33_ == ((guint8) 'I');
			} else {
				_tmp26_ = FALSE;
			}
			if (_tmp26_) {
				guint8* _tmp34_ = NULL;
				gint _tmp34__length1 = 0;
				guint8 _tmp35_ = 0U;
				_tmp34_ = signature;
				_tmp34__length1 = signature_length1;
				_tmp35_ = _tmp34_[3];
				_tmp25_ = _tmp35_ == ((guint8) 'T');
			} else {
				_tmp25_ = FALSE;
			}
			if (!_tmp25_) {
				GError* _tmp36_ = NULL;
				_tmp36_ = g_error_new_literal (GPX_FILE_ERROR, GPX_FILE_ERROR_INVALID_FILE, "No valid FIT signature found.");
				_inner_error_ = _tmp36_;
				signature = (g_free (signature), NULL);
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch5_g_io_error;
				}
				if (_inner_error_->domain == GPX_FILE_ERROR) {
					goto __catch5_gpx_file_error;
				}
				signature = (g_free (signature), NULL);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		_tmp37_ = header_size;
		if (((gint) _tmp37_) == 14) {
			guint16 crc = 0U;
			GDataInputStream* _tmp38_ = NULL;
			guint16 _tmp39_ = 0U;
			_tmp38_ = fs;
			_tmp39_ = g_data_input_stream_read_uint16 (_tmp38_, NULL, &_inner_error_);
			crc = _tmp39_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				signature = (g_free (signature), NULL);
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch5_g_io_error;
				}
				if (_inner_error_->domain == GPX_FILE_ERROR) {
					goto __catch5_gpx_file_error;
				}
				signature = (g_free (signature), NULL);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		signature = (g_free (signature), NULL);
	}
	goto __finally5;
	__catch5_g_io_error:
	{
		GError* err = NULL;
		GError* _tmp40_ = NULL;
		GError* _tmp41_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp40_ = err;
		_tmp41_ = _g_error_copy0 (_tmp40_);
		_inner_error_ = _tmp41_;
		_g_error_free0 (err);
		goto __finally5;
	}
	goto __finally5;
	__catch5_gpx_file_error:
	{
		GError* err = NULL;
		GError* _tmp42_ = NULL;
		GError* _tmp43_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp42_ = err;
		_tmp43_ = _g_error_copy0 (_tmp42_);
		_inner_error_ = _tmp43_;
		_g_error_free0 (err);
		goto __finally5;
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if ((_inner_error_->domain == GPX_FILE_ERROR) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


static GpxFitFileFieldDefinitionHeader* _vala_array_dup1 (GpxFitFileFieldDefinitionHeader* self, int length) {
	return g_memdup (self, length * sizeof (GpxFitFileFieldDefinitionHeader));
}


static void gpx_fit_file_field_definition_copy (const GpxFitFileFieldDefinition* self, GpxFitFileFieldDefinition* dest) {
	gboolean _tmp0_ = FALSE;
	guint16 _tmp1_ = 0U;
	GpxFitFileFieldDefinitionHeader* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	GpxFitFileFieldDefinitionHeader* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = (*self).endian;
	(*dest).endian = _tmp0_;
	_tmp1_ = (*self).type;
	(*dest).type = _tmp1_;
	_tmp2_ = (*self).fields;
	_tmp2__length1 = (*self).fields_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup1 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	(*dest).fields = (g_free ((*dest).fields), NULL);
	(*dest).fields = _tmp3_;
	(*dest).fields_length1 = _tmp3__length1;
	(*dest)._fields_size_ = (*dest).fields_length1;
}


static void gpx_fit_file_field_definition_destroy (GpxFitFileFieldDefinition* self) {
	(*self).fields = (g_free ((*self).fields), NULL);
}


static GpxFitFileFieldDefinition* gpx_fit_file_field_definition_dup (const GpxFitFileFieldDefinition* self) {
	GpxFitFileFieldDefinition* dup;
	dup = g_new0 (GpxFitFileFieldDefinition, 1);
	gpx_fit_file_field_definition_copy (self, dup);
	return dup;
}


static void gpx_fit_file_field_definition_free (GpxFitFileFieldDefinition* self) {
	gpx_fit_file_field_definition_destroy (self);
	g_free (self);
}


static GType gpx_fit_file_field_definition_get_type (void) {
	static volatile gsize gpx_fit_file_field_definition_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_fit_file_field_definition_type_id__volatile)) {
		GType gpx_fit_file_field_definition_type_id;
		gpx_fit_file_field_definition_type_id = g_boxed_type_register_static ("GpxFitFileFieldDefinition", (GBoxedCopyFunc) gpx_fit_file_field_definition_dup, (GBoxedFreeFunc) gpx_fit_file_field_definition_free);
		g_once_init_leave (&gpx_fit_file_field_definition_type_id__volatile, gpx_fit_file_field_definition_type_id);
	}
	return gpx_fit_file_field_definition_type_id__volatile;
}


static GpxFitFileFieldDefinitionHeader* gpx_fit_file_field_definition_header_dup (const GpxFitFileFieldDefinitionHeader* self) {
	GpxFitFileFieldDefinitionHeader* dup;
	dup = g_new0 (GpxFitFileFieldDefinitionHeader, 1);
	memcpy (dup, self, sizeof (GpxFitFileFieldDefinitionHeader));
	return dup;
}


static void gpx_fit_file_field_definition_header_free (GpxFitFileFieldDefinitionHeader* self) {
	g_free (self);
}


static GType gpx_fit_file_field_definition_header_get_type (void) {
	static volatile gsize gpx_fit_file_field_definition_header_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_fit_file_field_definition_header_type_id__volatile)) {
		GType gpx_fit_file_field_definition_header_type_id;
		gpx_fit_file_field_definition_header_type_id = g_boxed_type_register_static ("GpxFitFileFieldDefinitionHeader", (GBoxedCopyFunc) gpx_fit_file_field_definition_header_dup, (GBoxedFreeFunc) gpx_fit_file_field_definition_header_free);
		g_once_init_leave (&gpx_fit_file_field_definition_header_type_id__volatile, gpx_fit_file_field_definition_header_type_id);
	}
	return gpx_fit_file_field_definition_header_type_id__volatile;
}


static void gpx_fit_file_class_init (GpxFitFileClass * klass) {
	gpx_fit_file_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GpxFitFilePrivate));
	G_OBJECT_CLASS (klass)->finalize = gpx_fit_file_finalize;
}


static void gpx_fit_file_instance_init (GpxFitFile * self) {
	GpxFitFileFieldDefinition* _tmp0_ = NULL;
	self->priv = GPX_FIT_FILE_GET_PRIVATE (self);
	self->priv->track = NULL;
	self->priv->data_length = (guint32) 0;
	_tmp0_ = g_new0 (GpxFitFileFieldDefinition, MAX_LOCAL_DEFINITIONS);
	self->priv->defs = _tmp0_;
	self->priv->defs_length1 = MAX_LOCAL_DEFINITIONS;
	self->priv->_defs_size_ = self->priv->defs_length1;
}


static void gpx_fit_file_finalize (GObject* obj) {
	GpxFitFile * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GPX_TYPE_FIT_FILE, GpxFitFile);
	_g_object_unref0 (self->priv->track);
	self->priv->defs = (_vala_GpxFitFileFieldDefinition_array_free (self->priv->defs, self->priv->defs_length1), NULL);
	G_OBJECT_CLASS (gpx_fit_file_parent_class)->finalize (obj);
}


GType gpx_fit_file_get_type (void) {
	static volatile gsize gpx_fit_file_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_fit_file_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GpxFitFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gpx_fit_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GpxFitFile), 0, (GInstanceInitFunc) gpx_fit_file_instance_init, NULL };
		GType gpx_fit_file_type_id;
		gpx_fit_file_type_id = g_type_register_static (GPX_TYPE_FILE_BASE, "GpxFitFile", &g_define_type_info, 0);
		g_once_init_leave (&gpx_fit_file_type_id__volatile, gpx_fit_file_type_id);
	}
	return gpx_fit_file_type_id__volatile;
}



