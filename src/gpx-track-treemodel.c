/* gpx-track-treemodel.c generated by valac 0.28.1, the Vala compiler
 * generated from gpx-track-treemodel.vala, do not modify */

/* Gpx Viewer
 * Copyright (C) 2009-2015 Qball Cow <qball@sarine.nl>
 * Project homepage: http://blog.sarine.nl/

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <glib.h>
#include <glib-object.h>
#include "gpx.h"
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gtk/gtk.h>
#include <time.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gpx_point_unref0(var) ((var == NULL) ? NULL : (var = (gpx_point_unref (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GpxTrackTreeModelPrivate {
	GType* ColumnType;
	gint ColumnType_length1;
	gint _ColumnType_size_;
	gint stamp;
	GpxTrack* track;
};


static gpointer gpx_track_tree_model_parent_class = NULL;
static GtkTreeModelIface* gpx_track_tree_model_gtk_tree_model_parent_iface = NULL;

#define GPX_TRACK_TREE_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPX_TYPE_TRACK_TREE_MODEL, GpxTrackTreeModelPrivate))
enum  {
	GPX_TRACK_TREE_MODEL_DUMMY_PROPERTY
};
static GType gpx_track_tree_model_real_get_column_type (GtkTreeModel* base, gint index_);
static gboolean gpx_track_tree_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path);
static gint gpx_track_tree_model_real_get_n_columns (GtkTreeModel* base);
static GtkTreePath* gpx_track_tree_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter);
static void gpx_track_tree_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value);
static gboolean gpx_track_tree_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent);
static gboolean gpx_track_tree_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter);
static gint gpx_track_tree_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter);
static GtkTreeModelFlags gpx_track_tree_model_real_get_flags (GtkTreeModel* base);
static gboolean gpx_track_tree_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean gpx_track_tree_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n);
static gboolean gpx_track_tree_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child);
static void gpx_track_tree_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void gpx_track_tree_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void gpx_track_tree_model_finalize (GObject* obj);


GType gpx_track_tree_model_column_get_type (void) {
	static volatile gsize gpx_track_tree_model_column_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_track_tree_model_column_type_id__volatile)) {
		static const GEnumValue values[] = {{GPX_TRACK_TREE_MODEL_COLUMN_TIME, "GPX_TRACK_TREE_MODEL_COLUMN_TIME", "time"}, {GPX_TRACK_TREE_MODEL_COLUMN_DISTANCE, "GPX_TRACK_TREE_MODEL_COLUMN_DISTANCE", "distance"}, {GPX_TRACK_TREE_MODEL_COLUMN_ELEVATION, "GPX_TRACK_TREE_MODEL_COLUMN_ELEVATION", "elevation"}, {GPX_TRACK_TREE_MODEL_COLUMN_SPEED, "GPX_TRACK_TREE_MODEL_COLUMN_SPEED", "speed"}, {GPX_TRACK_TREE_MODEL_COLUMN_NUM_COLUMNS, "GPX_TRACK_TREE_MODEL_COLUMN_NUM_COLUMNS", "num-columns"}, {0, NULL, NULL}};
		GType gpx_track_tree_model_column_type_id;
		gpx_track_tree_model_column_type_id = g_enum_register_static ("GpxTrackTreeModelColumn", values);
		g_once_init_leave (&gpx_track_tree_model_column_type_id__volatile, gpx_track_tree_model_column_type_id);
	}
	return gpx_track_tree_model_column_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GpxTrackTreeModel* gpx_track_tree_model_construct (GType object_type, GpxTrack* track) {
	GpxTrackTreeModel * self = NULL;
	GpxTrack* _tmp0_ = NULL;
	GpxTrack* _tmp1_ = NULL;
	g_return_val_if_fail (track != NULL, NULL);
	self = (GpxTrackTreeModel*) g_object_new (object_type, NULL);
	_tmp0_ = track;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->track);
	self->priv->track = _tmp1_;
	return self;
}


GpxTrackTreeModel* gpx_track_tree_model_new (GpxTrack* track) {
	return gpx_track_tree_model_construct (GPX_TYPE_TRACK_TREE_MODEL, track);
}


static GType gpx_track_tree_model_real_get_column_type (GtkTreeModel* base, gint index_) {
	GpxTrackTreeModel * self;
	GType result = 0UL;
	GType* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	GType _tmp2_ = 0UL;
	self = (GpxTrackTreeModel*) base;
	_tmp0_ = self->priv->ColumnType;
	_tmp0__length1 = self->priv->ColumnType_length1;
	_tmp1_ = index_;
	_tmp2_ = _tmp0_[_tmp1_];
	result = _tmp2_;
	return result;
}


static gpointer _gpx_point_ref0 (gpointer self) {
	return self ? gpx_point_ref (self) : NULL;
}


static gboolean gpx_track_tree_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path) {
	GpxTrackTreeModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	gint depth = 0;
	GtkTreePath* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint n = 0;
	GtkTreePath* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gboolean _tmp7_ = FALSE;
	gint _tmp8_ = 0;
	GpxPoint* p = NULL;
	GpxTrack* _tmp13_ = NULL;
	GList* _tmp14_ = NULL;
	gint _tmp15_ = 0;
	gconstpointer _tmp16_ = NULL;
	GpxPoint* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	self = (GpxTrackTreeModel*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = path;
	_tmp1_ = gtk_tree_path_get_depth (_tmp0_);
	depth = _tmp1_;
	_tmp2_ = depth;
	_vala_assert (_tmp2_ == 1, "depth == 1");
	_tmp3_ = path;
	_tmp5_ = gtk_tree_path_get_indices_with_depth (_tmp3_, &_tmp4_);
	_tmp6_ = _tmp5_[0];
	n = _tmp6_;
	_tmp8_ = n;
	if (_tmp8_ >= 0) {
		gint _tmp9_ = 0;
		GpxTrack* _tmp10_ = NULL;
		GList* _tmp11_ = NULL;
		guint _tmp12_ = 0U;
		_tmp9_ = n;
		_tmp10_ = self->priv->track;
		_tmp11_ = _tmp10_->points;
		_tmp12_ = g_list_length (_tmp11_);
		_tmp7_ = _tmp9_ < ((gint) _tmp12_);
	} else {
		_tmp7_ = FALSE;
	}
	_vala_assert (_tmp7_, "n >= 0 && n < (int)this.track.points.length ()");
	_tmp13_ = self->priv->track;
	_tmp14_ = _tmp13_->points;
	_tmp15_ = n;
	_tmp16_ = g_list_nth_data (_tmp14_, (guint) _tmp15_);
	_tmp17_ = _gpx_point_ref0 ((GpxPoint*) _tmp16_);
	p = _tmp17_;
	_tmp18_ = self->priv->stamp;
	_vala_iter.stamp = _tmp18_;
	_vala_iter.user_data = p;
	_vala_iter.user_data2 = NULL;
	_vala_iter.user_data3 = NULL;
	result = TRUE;
	_gpx_point_unref0 (p);
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gint gpx_track_tree_model_real_get_n_columns (GtkTreeModel* base) {
	GpxTrackTreeModel * self;
	gint result = 0;
	self = (GpxTrackTreeModel*) base;
	result = (gint) GPX_TRACK_TREE_MODEL_COLUMN_NUM_COLUMNS;
	return result;
}


/**
         * Given an iter, returns a path
         */
static GtkTreePath* gpx_track_tree_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter) {
	GpxTrackTreeModel * self;
	GtkTreePath* result = NULL;
	GtkTreeIter _tmp0_ = {0};
	void* _tmp1_ = NULL;
	GpxPoint* p = NULL;
	GtkTreeIter _tmp2_ = {0};
	void* _tmp3_ = NULL;
	GpxPoint* _tmp4_ = NULL;
	GtkTreePath* path = NULL;
	GtkTreePath* _tmp5_ = NULL;
	gint pos = 0;
	GpxTrack* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	self = (GpxTrackTreeModel*) base;
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = *iter;
	_tmp1_ = _tmp0_.user_data;
	_vala_assert (_tmp1_ != NULL, "iter.user_data != null");
	_tmp2_ = *iter;
	_tmp3_ = _tmp2_.user_data;
	_tmp4_ = _gpx_point_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GPX_TYPE_POINT) ? ((GpxPoint*) _tmp3_) : NULL);
	p = _tmp4_;
	_tmp5_ = gtk_tree_path_new ();
	path = _tmp5_;
	_tmp6_ = self->priv->track;
	_tmp7_ = _tmp6_->points;
	_tmp8_ = g_list_index (_tmp7_, p);
	pos = _tmp8_;
	_vala_assert (pos != (-1), "pos != -1");
	gtk_tree_path_append_index (path, pos);
	result = path;
	_gpx_point_unref0 (p);
	return result;
}


static void g_time_local (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	localtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


static gchar* g_time_format (struct tm *self, const gchar* format) {
	gchar* result = NULL;
	gchar* buffer = NULL;
	gchar* _tmp0_ = NULL;
	gint buffer_length1 = 0;
	gint _buffer_size_ = 0;
	gchar* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (format != NULL, NULL);
	_tmp0_ = g_new0 (gchar, 64);
	buffer = _tmp0_;
	buffer_length1 = 64;
	_buffer_size_ = buffer_length1;
	_tmp1_ = buffer;
	_tmp1__length1 = buffer_length1;
	_tmp2_ = format;
	strftime (_tmp1_, _tmp1__length1, _tmp2_, &(*self));
	_tmp3_ = buffer;
	_tmp3__length1 = buffer_length1;
	_tmp4_ = g_strdup ((const gchar*) _tmp3_);
	result = _tmp4_;
	buffer = (g_free (buffer), NULL);
	return result;
}


static void gpx_track_tree_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value) {
	GpxTrackTreeModel * self;
	GValue _vala_value = {0};
	GtkTreeIter _tmp0_ = {0};
	void* _tmp1_ = NULL;
	GpxPoint* p = NULL;
	GtkTreeIter _tmp2_ = {0};
	void* _tmp3_ = NULL;
	GpxPoint* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	GType _tmp6_ = 0UL;
	GValue _tmp7_ = {0};
	GValue _tmp8_ = {0};
	gint _tmp9_ = 0;
	self = (GpxTrackTreeModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = _tmp0_.user_data;
	_vala_assert (_tmp1_ != NULL, "iter.user_data != null");
	_tmp2_ = *iter;
	_tmp3_ = _tmp2_.user_data;
	_tmp4_ = _gpx_point_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GPX_TYPE_POINT) ? ((GpxPoint*) _tmp3_) : NULL);
	p = _tmp4_;
	_tmp5_ = column;
	_tmp6_ = gtk_tree_model_get_column_type ((GtkTreeModel*) self, _tmp5_);
	g_value_init (&_tmp7_, _tmp6_);
	G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
	_vala_value = _tmp7_;
	_tmp8_ = _vala_value;
	_tmp9_ = column;
	switch (_tmp9_) {
		case GPX_TRACK_TREE_MODEL_COLUMN_TIME:
		{
			struct tm t = {0};
			GpxPoint* _tmp10_ = NULL;
			time_t _tmp11_ = 0;
			struct tm _tmp12_ = {0};
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_ = NULL;
			_tmp10_ = p;
			_tmp11_ = gpx_point_get_time (_tmp10_);
			g_time_local (_tmp11_, &_tmp12_);
			t = _tmp12_;
			_tmp13_ = g_time_format (&t, "%D - %X");
			_tmp14_ = _tmp13_;
			g_value_set_string (&_vala_value, _tmp14_);
			_g_free0 (_tmp14_);
			break;
		}
		case GPX_TRACK_TREE_MODEL_COLUMN_DISTANCE:
		{
			GpxPoint* _tmp15_ = NULL;
			gdouble _tmp16_ = 0.0;
			_tmp15_ = p;
			_tmp16_ = _tmp15_->distance;
			g_value_set_double (&_vala_value, _tmp16_);
			break;
		}
		case GPX_TRACK_TREE_MODEL_COLUMN_ELEVATION:
		{
			GpxPoint* _tmp17_ = NULL;
			gdouble _tmp18_ = 0.0;
			_tmp17_ = p;
			_tmp18_ = _tmp17_->elevation;
			g_value_set_double (&_vala_value, _tmp18_);
			break;
		}
		case GPX_TRACK_TREE_MODEL_COLUMN_SPEED:
		{
			GpxPoint* _tmp19_ = NULL;
			gdouble _tmp20_ = 0.0;
			_tmp19_ = p;
			_tmp20_ = _tmp19_->speed;
			g_value_set_double (&_vala_value, _tmp20_);
			break;
		}
		default:
		{
			break;
		}
	}
	_gpx_point_unref0 (p);
	if (value) {
		*value = _vala_value;
	} else {
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
	}
}


/**
         * Should never be reached since iter_has_child is never true
         */
static gboolean gpx_track_tree_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent) {
	GpxTrackTreeModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	self = (GpxTrackTreeModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	result = FALSE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


/**
         * always false since this is a list
         */
static gboolean gpx_track_tree_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter) {
	GpxTrackTreeModel * self;
	gboolean result = FALSE;
	self = (GpxTrackTreeModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	result = FALSE;
	return result;
}


/**
         * Number of children for an iter: treated only the special case,
         * where iter == null, returns the number of elements in the list
         */
static gint gpx_track_tree_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter) {
	GpxTrackTreeModel * self;
	gint result = 0;
	GtkTreeIter* _tmp0_ = NULL;
	self = (GpxTrackTreeModel*) base;
	_tmp0_ = iter;
	if (_tmp0_ == NULL) {
		guint n_children = 0U;
		GpxTrack* _tmp1_ = NULL;
		GList* _tmp2_ = NULL;
		guint _tmp3_ = 0U;
		guint _tmp4_ = 0U;
		_tmp1_ = self->priv->track;
		_tmp2_ = _tmp1_->points;
		_tmp3_ = g_list_length (_tmp2_);
		n_children = _tmp3_;
		_tmp4_ = n_children;
		result = (gint) _tmp4_;
		return result;
	} else {
		result = 0;
		return result;
	}
}


static GtkTreeModelFlags gpx_track_tree_model_real_get_flags (GtkTreeModel* base) {
	GpxTrackTreeModel * self;
	GtkTreeModelFlags result = 0;
	GtkTreeModelFlags flags = 0;
	self = (GpxTrackTreeModel*) base;
	flags = GTK_TREE_MODEL_LIST_ONLY | GTK_TREE_MODEL_ITERS_PERSIST;
	result = flags;
	return result;
}


/**
         * Given an iter, modify it to point to the next file
         */
static gboolean gpx_track_tree_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter) {
	GpxTrackTreeModel * self;
	gboolean result = FALSE;
	GtkTreeIter _tmp0_ = {0};
	void* _tmp1_ = NULL;
	GpxPoint* p = NULL;
	GtkTreeIter _tmp2_ = {0};
	void* _tmp3_ = NULL;
	GpxPoint* _tmp4_ = NULL;
	GList* node = NULL;
	GpxTrack* _tmp5_ = NULL;
	GList* _tmp6_ = NULL;
	GpxPoint* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	GList* _tmp10_ = NULL;
	self = (GpxTrackTreeModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = *iter;
	_tmp1_ = _tmp0_.user_data;
	_vala_assert (_tmp1_ != NULL, "iter.user_data != null");
	_tmp2_ = *iter;
	_tmp3_ = _tmp2_.user_data;
	_tmp4_ = _gpx_point_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GPX_TYPE_POINT) ? ((GpxPoint*) _tmp3_) : NULL);
	p = _tmp4_;
	_tmp5_ = self->priv->track;
	_tmp6_ = _tmp5_->points;
	_tmp7_ = p;
	_tmp8_ = g_list_find (_tmp6_, _tmp7_);
	node = _tmp8_;
	_tmp10_ = node;
	if (_tmp10_ != NULL) {
		GList* _tmp11_ = NULL;
		GList* _tmp12_ = NULL;
		_tmp11_ = node;
		_tmp12_ = _tmp11_->next;
		_tmp9_ = _tmp12_ != NULL;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		gint _tmp13_ = 0;
		GList* _tmp14_ = NULL;
		GList* _tmp15_ = NULL;
		gconstpointer _tmp16_ = NULL;
		_tmp13_ = self->priv->stamp;
		(*iter).stamp = _tmp13_;
		_tmp14_ = node;
		_tmp15_ = _tmp14_->next;
		_tmp16_ = _tmp15_->data;
		(*iter).user_data = _tmp16_;
		result = TRUE;
		_gpx_point_unref0 (p);
		return result;
	}
	result = FALSE;
	_gpx_point_unref0 (p);
	return result;
}


static gboolean gpx_track_tree_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n) {
	GpxTrackTreeModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	GtkTreeIter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_ = 0;
	gint _tmp7_ = 0;
	GpxTrack* _tmp8_ = NULL;
	GList* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	gconstpointer _tmp11_ = NULL;
	self = (GpxTrackTreeModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = parent;
	if (_tmp0_ == NULL) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp2_ = n;
	if (_tmp2_ < 0) {
		_tmp1_ = TRUE;
	} else {
		gint _tmp3_ = 0;
		GpxTrack* _tmp4_ = NULL;
		GList* _tmp5_ = NULL;
		guint _tmp6_ = 0U;
		_tmp3_ = n;
		_tmp4_ = self->priv->track;
		_tmp5_ = _tmp4_->points;
		_tmp6_ = g_list_length (_tmp5_);
		_tmp1_ = ((guint) _tmp3_) >= _tmp6_;
	}
	if (_tmp1_) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp7_ = self->priv->stamp;
	_vala_iter.stamp = _tmp7_;
	_tmp8_ = self->priv->track;
	_tmp9_ = _tmp8_->points;
	_tmp10_ = n;
	_tmp11_ = g_list_nth_data (_tmp9_, (guint) _tmp10_);
	_vala_iter.user_data = (GpxPoint*) _tmp11_;
	result = TRUE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


/**
         * again, not implemented since this is not a tree
         */
static gboolean gpx_track_tree_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child) {
	GpxTrackTreeModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	self = (GpxTrackTreeModel*) base;
	g_return_val_if_fail (child != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	result = FALSE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static void gpx_track_tree_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	GpxTrackTreeModel * self;
	self = (GpxTrackTreeModel*) base;
	g_return_if_fail (iter != NULL);
}


static void gpx_track_tree_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	GpxTrackTreeModel * self;
	self = (GpxTrackTreeModel*) base;
	g_return_if_fail (iter != NULL);
}


static void gpx_track_tree_model_class_init (GpxTrackTreeModelClass * klass) {
	gpx_track_tree_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GpxTrackTreeModelPrivate));
	G_OBJECT_CLASS (klass)->finalize = gpx_track_tree_model_finalize;
}


static void gpx_track_tree_model_gtk_tree_model_interface_init (GtkTreeModelIface * iface) {
	gpx_track_tree_model_gtk_tree_model_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_column_type = (GType (*)(GtkTreeModel*, gint)) gpx_track_tree_model_real_get_column_type;
	iface->get_iter = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreePath*)) gpx_track_tree_model_real_get_iter;
	iface->get_n_columns = (gint (*)(GtkTreeModel*)) gpx_track_tree_model_real_get_n_columns;
	iface->get_path = (GtkTreePath* (*)(GtkTreeModel*, GtkTreeIter*)) gpx_track_tree_model_real_get_path;
	iface->get_value = (void (*)(GtkTreeModel*, GtkTreeIter*, gint, GValue*)) gpx_track_tree_model_real_get_value;
	iface->iter_children = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) gpx_track_tree_model_real_iter_children;
	iface->iter_has_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) gpx_track_tree_model_real_iter_has_child;
	iface->iter_n_children = (gint (*)(GtkTreeModel*, GtkTreeIter*)) gpx_track_tree_model_real_iter_n_children;
	iface->get_flags = (GtkTreeModelFlags (*)(GtkTreeModel*)) gpx_track_tree_model_real_get_flags;
	iface->iter_next = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) gpx_track_tree_model_real_iter_next;
	iface->iter_nth_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gint)) gpx_track_tree_model_real_iter_nth_child;
	iface->iter_parent = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) gpx_track_tree_model_real_iter_parent;
	iface->ref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) gpx_track_tree_model_real_ref_node;
	iface->unref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) gpx_track_tree_model_real_unref_node;
}


static void gpx_track_tree_model_instance_init (GpxTrackTreeModel * self) {
	GType* _tmp0_ = NULL;
	self->priv = GPX_TRACK_TREE_MODEL_GET_PRIVATE (self);
	_tmp0_ = g_new0 (GType, 4);
	_tmp0_[0] = G_TYPE_STRING;
	_tmp0_[1] = G_TYPE_DOUBLE;
	_tmp0_[2] = G_TYPE_DOUBLE;
	_tmp0_[3] = G_TYPE_DOUBLE;
	self->priv->ColumnType = _tmp0_;
	self->priv->ColumnType_length1 = 4;
	self->priv->_ColumnType_size_ = self->priv->ColumnType_length1;
	self->priv->stamp = 42;
	self->priv->track = NULL;
}


static void gpx_track_tree_model_finalize (GObject* obj) {
	GpxTrackTreeModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GPX_TYPE_TRACK_TREE_MODEL, GpxTrackTreeModel);
	self->priv->ColumnType = (g_free (self->priv->ColumnType), NULL);
	_g_object_unref0 (self->priv->track);
	G_OBJECT_CLASS (gpx_track_tree_model_parent_class)->finalize (obj);
}


GType gpx_track_tree_model_get_type (void) {
	static volatile gsize gpx_track_tree_model_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_track_tree_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GpxTrackTreeModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gpx_track_tree_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GpxTrackTreeModel), 0, (GInstanceInitFunc) gpx_track_tree_model_instance_init, NULL };
		static const GInterfaceInfo gtk_tree_model_info = { (GInterfaceInitFunc) gpx_track_tree_model_gtk_tree_model_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gpx_track_tree_model_type_id;
		gpx_track_tree_model_type_id = g_type_register_static (G_TYPE_OBJECT, "GpxTrackTreeModel", &g_define_type_info, 0);
		g_type_add_interface_static (gpx_track_tree_model_type_id, GTK_TYPE_TREE_MODEL, &gtk_tree_model_info);
		g_once_init_leave (&gpx_track_tree_model_type_id__volatile, gpx_track_tree_model_type_id);
	}
	return gpx_track_tree_model_type_id__volatile;
}



