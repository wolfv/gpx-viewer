/* gpx-parser.c generated by valac 0.28.1, the Vala compiler
 * generated from gpx-parser.vala, do not modify */

/* Gpx Viewer
 * Copyright (C) 2009-2015 Qball Cow <qball@sarine.nl>
 * Project homepage: http://blog.sarine.nl/

 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <glib.h>
#include <glib-object.h>
#include "gpx.h"
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _gpx_point_unref0(var) ((var == NULL) ? NULL : (var = (gpx_point_unref (var), NULL)))
typedef struct _GpxParamSpecPoint GpxParamSpecPoint;
#define __g_list_free__gpx_point_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__gpx_point_unref0_ (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _GpxPointPrivate {
	gchar* _name;
	time_t utime;
};

struct _GpxParamSpecPoint {
	GParamSpec parent_instance;
};

struct _GpxTrackPrivate {
	gchar* _name;
	GpxPoint* last;
};


static gpointer gpx_point_parent_class = NULL;
static gpointer gpx_track_parent_class = NULL;
static gpointer gpx_file_base_parent_class = NULL;

#define GPX_POINT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPX_TYPE_POINT, GpxPointPrivate))
enum  {
	GPX_POINT_DUMMY_PROPERTY
};
static void gpx_point_finalize (GpxPoint* obj);
#define GPX_TRACK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPX_TYPE_TRACK, GpxTrackPrivate))
enum  {
	GPX_TRACK_DUMMY_PROPERTY,
	GPX_TRACK_NAME
};
static void _gpx_point_unref0_ (gpointer var);
static void _g_list_free__gpx_point_unref0_ (GList* self);
static void gpx_track_finalize (GObject* obj);
static void _vala_gpx_track_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gpx_track_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
enum  {
	GPX_FILE_BASE_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void gpx_file_base_finalize (GObject* obj);


GpxHeartRateMonitorPoint* gpx_heart_rate_monitor_point_dup (const GpxHeartRateMonitorPoint* self) {
	GpxHeartRateMonitorPoint* dup;
	dup = g_new0 (GpxHeartRateMonitorPoint, 1);
	memcpy (dup, self, sizeof (GpxHeartRateMonitorPoint));
	return dup;
}


void gpx_heart_rate_monitor_point_free (GpxHeartRateMonitorPoint* self) {
	g_free (self);
}


GType gpx_heart_rate_monitor_point_get_type (void) {
	static volatile gsize gpx_heart_rate_monitor_point_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_heart_rate_monitor_point_type_id__volatile)) {
		GType gpx_heart_rate_monitor_point_type_id;
		gpx_heart_rate_monitor_point_type_id = g_boxed_type_register_static ("GpxHeartRateMonitorPoint", (GBoxedCopyFunc) gpx_heart_rate_monitor_point_dup, (GBoxedFreeFunc) gpx_heart_rate_monitor_point_free);
		g_once_init_leave (&gpx_heart_rate_monitor_point_type_id__volatile, gpx_heart_rate_monitor_point_type_id);
	}
	return gpx_heart_rate_monitor_point_type_id__volatile;
}


GpxHeartRateMonitorTrack* gpx_heart_rate_monitor_track_dup (const GpxHeartRateMonitorTrack* self) {
	GpxHeartRateMonitorTrack* dup;
	dup = g_new0 (GpxHeartRateMonitorTrack, 1);
	memcpy (dup, self, sizeof (GpxHeartRateMonitorTrack));
	return dup;
}


void gpx_heart_rate_monitor_track_free (GpxHeartRateMonitorTrack* self) {
	g_free (self);
}


GType gpx_heart_rate_monitor_track_get_type (void) {
	static volatile gsize gpx_heart_rate_monitor_track_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_heart_rate_monitor_track_type_id__volatile)) {
		GType gpx_heart_rate_monitor_track_type_id;
		gpx_heart_rate_monitor_track_type_id = g_boxed_type_register_static ("GpxHeartRateMonitorTrack", (GBoxedCopyFunc) gpx_heart_rate_monitor_track_dup, (GBoxedFreeFunc) gpx_heart_rate_monitor_track_free);
		g_once_init_leave (&gpx_heart_rate_monitor_track_type_id__volatile, gpx_heart_rate_monitor_track_type_id);
	}
	return gpx_heart_rate_monitor_track_type_id__volatile;
}


gboolean gpx_point_has_position (GpxPoint* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gdouble _tmp1_ = 0.0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->lat;
	if (_tmp1_ == ((gdouble) 1000)) {
		_tmp0_ = TRUE;
	} else {
		gdouble _tmp2_ = 0.0;
		_tmp2_ = self->lon;
		_tmp0_ = _tmp2_ == ((gdouble) 1000);
	}
	result = !_tmp0_;
	return result;
}


/**
         * Make a clean copy off the point.
         * Only position and time is copied.
         */
GpxPoint* gpx_point_copy (GpxPoint* self) {
	GpxPoint* result = NULL;
	GpxPoint* p = NULL;
	GpxPoint* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	GpxHeartRateMonitorPoint _tmp10_ = {0};
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gpx_point_new ();
	p = _tmp0_;
	_tmp1_ = self->priv->_name;
	gpx_point_set_name (p, _tmp1_);
	_tmp2_ = self->lat;
	p->lat = _tmp2_;
	_tmp3_ = self->lon;
	p->lon = _tmp3_;
	_tmp4_ = self->lat_dec;
	p->lat_dec = _tmp4_;
	_tmp5_ = self->lon_dec;
	p->lon_dec = _tmp5_;
	_tmp6_ = self->time;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (p->time);
	p->time = _tmp7_;
	_tmp8_ = self->elevation;
	p->elevation = _tmp8_;
	_tmp9_ = self->smooth_elevation;
	p->smooth_elevation = _tmp9_;
	_tmp10_ = self->tpe;
	p->tpe = _tmp10_;
	result = p;
	return result;
}


void gpx_point_set_position_lat (GpxPoint* self, gdouble lat_d) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = lat_d;
	self->lat_dec = _tmp0_;
	_tmp1_ = lat_d;
	self->lat = ((2 * G_PI) * _tmp1_) / 360.0;
}


void gpx_point_set_position_lon (GpxPoint* self, gdouble lon_d) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = lon_d;
	self->lon_dec = _tmp0_;
	_tmp1_ = lon_d;
	self->lon = ((2 * G_PI) * _tmp1_) / 360.0;
}


void gpx_point_set_position (GpxPoint* self, gdouble lat, gdouble lon) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = lat;
	self->lat_dec = _tmp0_;
	_tmp1_ = lon;
	self->lon_dec = _tmp1_;
	_tmp2_ = lat;
	self->lat = ((2 * G_PI) * _tmp2_) / 360.0;
	_tmp3_ = lon;
	self->lon = ((2 * G_PI) * _tmp3_) / 360.0;
}


time_t gpx_point_get_time (GpxPoint* self) {
	time_t result = 0;
	const gchar* _tmp0_ = NULL;
	time_t _tmp1_ = 0;
	struct tm ta = {0};
	const gchar* _tmp3_ = NULL;
	time_t _tmp4_ = 0;
	time_t _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->time;
	if (_tmp0_ == NULL) {
		result = (time_t) 0;
		return result;
	}
	_tmp1_ = self->priv->utime;
	if (_tmp1_ > ((time_t) 0)) {
		time_t _tmp2_ = 0;
		_tmp2_ = self->priv->utime;
		result = _tmp2_;
		return result;
	}
	memset (&ta, 0, sizeof (struct tm));
	_tmp3_ = self->time;
	strptime (_tmp3_, "%FT%T%z", &ta);
	_tmp4_ = mktime (&ta);
	self->priv->utime = _tmp4_;
	_tmp5_ = self->priv->utime;
	result = _tmp5_;
	return result;
}


GpxPoint* gpx_point_construct (GType object_type) {
	GpxPoint* self = NULL;
	self = (GpxPoint*) g_type_create_instance (object_type);
	return self;
}


GpxPoint* gpx_point_new (void) {
	return gpx_point_construct (GPX_TYPE_POINT);
}


const gchar* gpx_point_get_name (GpxPoint* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}


void gpx_point_set_name (GpxPoint* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp1_;
}


static void gpx_value_point_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gpx_value_point_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gpx_point_unref (value->data[0].v_pointer);
	}
}


static void gpx_value_point_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gpx_point_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gpx_value_point_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gpx_value_point_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GpxPoint* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gpx_point_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gpx_value_point_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GpxPoint** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gpx_point_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gpx_param_spec_point (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GpxParamSpecPoint* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GPX_TYPE_POINT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gpx_value_get_point (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GPX_TYPE_POINT), NULL);
	return value->data[0].v_pointer;
}


void gpx_value_set_point (GValue* value, gpointer v_object) {
	GpxPoint* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GPX_TYPE_POINT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GPX_TYPE_POINT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gpx_point_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gpx_point_unref (old);
	}
}


void gpx_value_take_point (GValue* value, gpointer v_object) {
	GpxPoint* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GPX_TYPE_POINT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GPX_TYPE_POINT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gpx_point_unref (old);
	}
}


static void gpx_point_class_init (GpxPointClass * klass) {
	gpx_point_parent_class = g_type_class_peek_parent (klass);
	((GpxPointClass *) klass)->finalize = gpx_point_finalize;
	g_type_class_add_private (klass, sizeof (GpxPointPrivate));
}


static void gpx_point_instance_init (GpxPoint * self) {
	GpxHeartRateMonitorPoint _tmp0_ = {0};
	self->priv = GPX_POINT_GET_PRIVATE (self);
	self->priv->_name = NULL;
	self->lat = (gdouble) 1000;
	self->lon = (gdouble) 1000;
	self->lat_dec = (gdouble) 1000;
	self->lon_dec = (gdouble) 1000;
	self->distance = (gdouble) 0;
	self->speed = (gdouble) 0;
	self->stopped = FALSE;
	self->priv->utime = (time_t) 0;
	self->cadence = (guint32) 0;
	memset (&_tmp0_, 0, sizeof (GpxHeartRateMonitorPoint));
	_tmp0_.heartrate = 0;
	self->tpe = _tmp0_;
	self->ref_count = 1;
}


static void gpx_point_finalize (GpxPoint* obj) {
	GpxPoint * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GPX_TYPE_POINT, GpxPoint);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->_name);
	_g_free0 (self->time);
}


/**
     * Represents a point in the track or a waypoint.
     */
GType gpx_point_get_type (void) {
	static volatile gsize gpx_point_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_point_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gpx_value_point_init, gpx_value_point_free_value, gpx_value_point_copy_value, gpx_value_point_peek_pointer, "p", gpx_value_point_collect_value, "p", gpx_value_point_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GpxPointClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gpx_point_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GpxPoint), 0, (GInstanceInitFunc) gpx_point_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gpx_point_type_id;
		gpx_point_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GpxPoint", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gpx_point_type_id__volatile, gpx_point_type_id);
	}
	return gpx_point_type_id__volatile;
}


gpointer gpx_point_ref (gpointer instance) {
	GpxPoint* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gpx_point_unref (gpointer instance) {
	GpxPoint* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GPX_POINT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _gpx_point_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (gpx_point_unref (var), NULL));
}


static void _g_list_free__gpx_point_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _gpx_point_unref0_, NULL);
	g_list_free (self);
}


GpxPoint* gpx_track_get_last (GpxTrack* self) {
	GpxPoint* result = NULL;
	GpxPoint* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->last;
	result = _tmp0_;
	return result;
}


/** This function will try to remove useless points */
void gpx_track_filter_points (GpxTrack* self) {
	GList* a = NULL;
	GList* b = NULL;
	GList* c = NULL;
	gdouble davg = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble avg = 0.0;
	gdouble _tmp121_ = 0.0;
	gdouble _tmp122_ = 0.0;
	gdouble _tmp123_ = 0.0;
	gint _tmp143_ = 0;
	g_return_if_fail (self != NULL);
	a = NULL;
	b = NULL;
	c = NULL;
	_tmp0_ = gpx_track_get_track_average (self);
	davg = _tmp0_;
	{
		GList* iter = NULL;
		GList* _tmp1_ = NULL;
		GList* _tmp2_ = NULL;
		_tmp1_ = self->points;
		_tmp2_ = g_list_first (_tmp1_);
		iter = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				GList* _tmp6_ = NULL;
				GList* _tmp7_ = NULL;
				GList* _tmp9_ = NULL;
				GList* _tmp11_ = NULL;
				gboolean _tmp12_ = FALSE;
				gboolean _tmp13_ = FALSE;
				GList* _tmp14_ = NULL;
				if (!_tmp3_) {
					GList* _tmp4_ = NULL;
					GList* _tmp5_ = NULL;
					_tmp4_ = iter;
					_tmp5_ = _tmp4_->next;
					iter = _tmp5_;
				}
				_tmp3_ = FALSE;
				_tmp6_ = iter;
				if (!(_tmp6_ != NULL)) {
					break;
				}
				_tmp7_ = b;
				if (_tmp7_ != NULL) {
					GList* _tmp8_ = NULL;
					_tmp8_ = b;
					c = _tmp8_;
				}
				_tmp9_ = a;
				if (_tmp9_ != NULL) {
					GList* _tmp10_ = NULL;
					_tmp10_ = a;
					b = _tmp10_;
				}
				_tmp11_ = iter;
				a = _tmp11_;
				_tmp14_ = a;
				if (_tmp14_ != NULL) {
					GList* _tmp15_ = NULL;
					_tmp15_ = b;
					_tmp13_ = _tmp15_ != NULL;
				} else {
					_tmp13_ = FALSE;
				}
				if (_tmp13_) {
					GList* _tmp16_ = NULL;
					_tmp16_ = c;
					_tmp12_ = _tmp16_ != NULL;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					gdouble elapsed_ca = 0.0;
					GList* _tmp17_ = NULL;
					gconstpointer _tmp18_ = NULL;
					time_t _tmp19_ = 0;
					GList* _tmp20_ = NULL;
					gconstpointer _tmp21_ = NULL;
					time_t _tmp22_ = 0;
					gdouble elapsed_cb = 0.0;
					GList* _tmp23_ = NULL;
					gconstpointer _tmp24_ = NULL;
					time_t _tmp25_ = 0;
					GList* _tmp26_ = NULL;
					gconstpointer _tmp27_ = NULL;
					time_t _tmp28_ = 0;
					gdouble lat_rico_ca = 0.0;
					GList* _tmp29_ = NULL;
					gconstpointer _tmp30_ = NULL;
					gdouble _tmp31_ = 0.0;
					GList* _tmp32_ = NULL;
					gconstpointer _tmp33_ = NULL;
					gdouble _tmp34_ = 0.0;
					gdouble _tmp35_ = 0.0;
					gdouble lon_rico_ca = 0.0;
					GList* _tmp36_ = NULL;
					gconstpointer _tmp37_ = NULL;
					gdouble _tmp38_ = 0.0;
					GList* _tmp39_ = NULL;
					gconstpointer _tmp40_ = NULL;
					gdouble _tmp41_ = 0.0;
					gdouble _tmp42_ = 0.0;
					gdouble lat_rico_cb = 0.0;
					GList* _tmp43_ = NULL;
					gconstpointer _tmp44_ = NULL;
					gdouble _tmp45_ = 0.0;
					GList* _tmp46_ = NULL;
					gconstpointer _tmp47_ = NULL;
					gdouble _tmp48_ = 0.0;
					gdouble _tmp49_ = 0.0;
					gdouble lon_rico_cb = 0.0;
					GList* _tmp50_ = NULL;
					gconstpointer _tmp51_ = NULL;
					gdouble _tmp52_ = 0.0;
					GList* _tmp53_ = NULL;
					gconstpointer _tmp54_ = NULL;
					gdouble _tmp55_ = 0.0;
					gdouble _tmp56_ = 0.0;
					gdouble elv_rico_ca = 0.0;
					GList* _tmp57_ = NULL;
					gconstpointer _tmp58_ = NULL;
					gdouble _tmp59_ = 0.0;
					GList* _tmp60_ = NULL;
					gconstpointer _tmp61_ = NULL;
					gdouble _tmp62_ = 0.0;
					gdouble _tmp63_ = 0.0;
					gdouble elv_rico_cb = 0.0;
					GList* _tmp64_ = NULL;
					gconstpointer _tmp65_ = NULL;
					gdouble _tmp66_ = 0.0;
					GList* _tmp67_ = NULL;
					gconstpointer _tmp68_ = NULL;
					gdouble _tmp69_ = 0.0;
					gdouble _tmp70_ = 0.0;
					gdouble l = 0.0;
					gdouble _tmp71_ = 0.0;
					gdouble _tmp72_ = 0.0;
					gdouble _tmp73_ = 0.0;
					gdouble m = 0.0;
					gdouble _tmp74_ = 0.0;
					gdouble _tmp75_ = 0.0;
					gdouble _tmp76_ = 0.0;
					gdouble e = 0.0;
					gdouble _tmp77_ = 0.0;
					gdouble _tmp78_ = 0.0;
					gdouble _tmp79_ = 0.0;
					gdouble abs_diff = 0.0;
					GList* _tmp80_ = NULL;
					gconstpointer _tmp81_ = NULL;
					gdouble _tmp82_ = 0.0;
					GList* _tmp83_ = NULL;
					gconstpointer _tmp84_ = NULL;
					gdouble _tmp85_ = 0.0;
					gdouble _tmp86_ = 0.0;
					GList* _tmp87_ = NULL;
					gconstpointer _tmp88_ = NULL;
					gdouble _tmp89_ = 0.0;
					GList* _tmp90_ = NULL;
					gconstpointer _tmp91_ = NULL;
					gdouble _tmp92_ = 0.0;
					gdouble _tmp93_ = 0.0;
					gdouble diff = 0.0;
					GList* _tmp94_ = NULL;
					gconstpointer _tmp95_ = NULL;
					gdouble _tmp96_ = 0.0;
					GList* _tmp97_ = NULL;
					gconstpointer _tmp98_ = NULL;
					gdouble _tmp99_ = 0.0;
					GList* _tmp100_ = NULL;
					gconstpointer _tmp101_ = NULL;
					gdouble _tmp102_ = 0.0;
					GList* _tmp103_ = NULL;
					gconstpointer _tmp104_ = NULL;
					gdouble _tmp105_ = 0.0;
					gdouble _tmp106_ = 0.0;
					gboolean _tmp107_ = FALSE;
					gdouble _tmp108_ = 0.0;
					gdouble _tmp109_ = 0.0;
					_tmp17_ = a;
					_tmp18_ = _tmp17_->data;
					_tmp19_ = gpx_point_get_time ((GpxPoint*) _tmp18_);
					_tmp20_ = c;
					_tmp21_ = _tmp20_->data;
					_tmp22_ = gpx_point_get_time ((GpxPoint*) _tmp21_);
					elapsed_ca = (gdouble) (_tmp19_ - _tmp22_);
					_tmp23_ = a;
					_tmp24_ = _tmp23_->data;
					_tmp25_ = gpx_point_get_time ((GpxPoint*) _tmp24_);
					_tmp26_ = b;
					_tmp27_ = _tmp26_->data;
					_tmp28_ = gpx_point_get_time ((GpxPoint*) _tmp27_);
					elapsed_cb = (gdouble) (_tmp25_ - _tmp28_);
					_tmp29_ = a;
					_tmp30_ = _tmp29_->data;
					_tmp31_ = ((GpxPoint*) _tmp30_)->lat_dec;
					_tmp32_ = c;
					_tmp33_ = _tmp32_->data;
					_tmp34_ = ((GpxPoint*) _tmp33_)->lat_dec;
					_tmp35_ = elapsed_ca;
					lat_rico_ca = (_tmp31_ - _tmp34_) / ((gdouble) _tmp35_);
					_tmp36_ = a;
					_tmp37_ = _tmp36_->data;
					_tmp38_ = ((GpxPoint*) _tmp37_)->lon_dec;
					_tmp39_ = c;
					_tmp40_ = _tmp39_->data;
					_tmp41_ = ((GpxPoint*) _tmp40_)->lon_dec;
					_tmp42_ = elapsed_ca;
					lon_rico_ca = (_tmp38_ - _tmp41_) / ((gdouble) _tmp42_);
					_tmp43_ = b;
					_tmp44_ = _tmp43_->data;
					_tmp45_ = ((GpxPoint*) _tmp44_)->lat_dec;
					_tmp46_ = c;
					_tmp47_ = _tmp46_->data;
					_tmp48_ = ((GpxPoint*) _tmp47_)->lat_dec;
					_tmp49_ = elapsed_cb;
					lat_rico_cb = (_tmp45_ - _tmp48_) / ((gdouble) _tmp49_);
					_tmp50_ = b;
					_tmp51_ = _tmp50_->data;
					_tmp52_ = ((GpxPoint*) _tmp51_)->lon_dec;
					_tmp53_ = c;
					_tmp54_ = _tmp53_->data;
					_tmp55_ = ((GpxPoint*) _tmp54_)->lon_dec;
					_tmp56_ = elapsed_cb;
					lon_rico_cb = (_tmp52_ - _tmp55_) / ((gdouble) _tmp56_);
					_tmp57_ = a;
					_tmp58_ = _tmp57_->data;
					_tmp59_ = ((GpxPoint*) _tmp58_)->elevation;
					_tmp60_ = c;
					_tmp61_ = _tmp60_->data;
					_tmp62_ = ((GpxPoint*) _tmp61_)->elevation;
					_tmp63_ = elapsed_ca;
					elv_rico_ca = (_tmp59_ - _tmp62_) / ((gdouble) _tmp63_);
					_tmp64_ = a;
					_tmp65_ = _tmp64_->data;
					_tmp66_ = ((GpxPoint*) _tmp65_)->elevation;
					_tmp67_ = b;
					_tmp68_ = _tmp67_->data;
					_tmp69_ = ((GpxPoint*) _tmp68_)->elevation;
					_tmp70_ = elapsed_cb;
					elv_rico_cb = (_tmp66_ - _tmp69_) / ((gdouble) _tmp70_);
					_tmp71_ = lat_rico_ca;
					_tmp72_ = lat_rico_cb;
					_tmp73_ = fabs (1.0 - (_tmp71_ / _tmp72_));
					l = _tmp73_;
					_tmp74_ = lon_rico_ca;
					_tmp75_ = lon_rico_cb;
					_tmp76_ = fabs (1.0 - (_tmp74_ / _tmp75_));
					m = _tmp76_;
					_tmp77_ = elv_rico_ca;
					_tmp78_ = elv_rico_cb;
					_tmp79_ = fabs (1.0 - (_tmp77_ / _tmp78_));
					e = _tmp79_;
					_tmp80_ = b;
					_tmp81_ = _tmp80_->data;
					_tmp82_ = ((GpxPoint*) _tmp81_)->speed;
					_tmp83_ = a;
					_tmp84_ = _tmp83_->data;
					_tmp85_ = ((GpxPoint*) _tmp84_)->speed;
					_tmp86_ = fabs (_tmp82_ - _tmp85_);
					_tmp87_ = c;
					_tmp88_ = _tmp87_->data;
					_tmp89_ = ((GpxPoint*) _tmp88_)->speed;
					_tmp90_ = b;
					_tmp91_ = _tmp90_->data;
					_tmp92_ = ((GpxPoint*) _tmp91_)->speed;
					_tmp93_ = fabs (_tmp89_ - _tmp92_);
					abs_diff = _tmp86_ + _tmp93_;
					_tmp94_ = b;
					_tmp95_ = _tmp94_->data;
					_tmp96_ = ((GpxPoint*) _tmp95_)->speed;
					_tmp97_ = a;
					_tmp98_ = _tmp97_->data;
					_tmp99_ = ((GpxPoint*) _tmp98_)->speed;
					_tmp100_ = c;
					_tmp101_ = _tmp100_->data;
					_tmp102_ = ((GpxPoint*) _tmp101_)->speed;
					_tmp103_ = b;
					_tmp104_ = _tmp103_->data;
					_tmp105_ = ((GpxPoint*) _tmp104_)->speed;
					_tmp106_ = fabs ((_tmp96_ - _tmp99_) + (_tmp102_ - _tmp105_));
					diff = _tmp106_;
					_tmp108_ = diff;
					_tmp109_ = abs_diff;
					if (_tmp108_ < (0.2 * _tmp109_)) {
						gdouble _tmp110_ = 0.0;
						gdouble _tmp111_ = 0.0;
						_tmp110_ = abs_diff;
						_tmp111_ = davg;
						_tmp107_ = _tmp110_ > (3 * _tmp111_);
					} else {
						_tmp107_ = FALSE;
					}
					if (_tmp107_) {
						FILE* _tmp112_ = NULL;
						gdouble _tmp113_ = 0.0;
						gdouble _tmp114_ = 0.0;
						GList* _tmp115_ = NULL;
						_tmp112_ = stdout;
						_tmp113_ = diff;
						_tmp114_ = abs_diff;
						fprintf (_tmp112_, "----- %f %f filter points\n", _tmp113_, _tmp114_);
						_tmp115_ = b;
						self->points = g_list_remove_link (self->points, _tmp115_);
					} else {
						gdouble _tmp116_ = 0.0;
						_tmp116_ = l;
						if (_tmp116_ <= 0.2) {
							gdouble _tmp117_ = 0.0;
							_tmp117_ = m;
							if (_tmp117_ <= 0.2) {
								GList* _tmp118_ = NULL;
								gint _tmp119_ = 0;
								GList* _tmp120_ = NULL;
								_tmp118_ = b;
								self->points = g_list_remove_link (self->points, _tmp118_);
								_tmp119_ = self->filtered_points;
								self->filtered_points = _tmp119_ + 1;
								_tmp120_ = c;
								b = _tmp120_;
							}
						}
					}
				}
			}
		}
	}
	gpx_track_recalculate (self);
	_tmp121_ = gpx_track_get_track_average (self);
	avg = _tmp121_ / 20;
	_tmp123_ = avg;
	if (_tmp123_ > ((gdouble) 2)) {
		_tmp122_ = (gdouble) 2;
	} else {
		gdouble _tmp124_ = 0.0;
		_tmp124_ = avg;
		_tmp122_ = _tmp124_;
	}
	avg = _tmp122_;
	{
		GList* iter = NULL;
		GList* _tmp125_ = NULL;
		GList* _tmp126_ = NULL;
		_tmp125_ = self->points;
		_tmp126_ = g_list_first (_tmp125_);
		iter = _tmp126_;
		{
			gboolean _tmp127_ = FALSE;
			_tmp127_ = TRUE;
			while (TRUE) {
				GList* _tmp130_ = NULL;
				GpxPoint* p = NULL;
				GList* _tmp131_ = NULL;
				gconstpointer _tmp132_ = NULL;
				gboolean _tmp133_ = FALSE;
				gboolean _tmp134_ = FALSE;
				GpxPoint* _tmp135_ = NULL;
				gdouble _tmp136_ = 0.0;
				if (!_tmp127_) {
					GList* _tmp128_ = NULL;
					GList* _tmp129_ = NULL;
					_tmp128_ = iter;
					_tmp129_ = _tmp128_->next;
					iter = _tmp129_;
				}
				_tmp127_ = FALSE;
				_tmp130_ = iter;
				if (!(_tmp130_ != NULL)) {
					break;
				}
				_tmp131_ = iter;
				_tmp132_ = _tmp131_->data;
				p = (GpxPoint*) _tmp132_;
				_tmp135_ = p;
				_tmp136_ = _tmp135_->distance;
				if (_tmp136_ < 0.01) {
					_tmp134_ = TRUE;
				} else {
					GpxPoint* _tmp137_ = NULL;
					gdouble _tmp138_ = 0.0;
					gdouble _tmp139_ = 0.0;
					_tmp137_ = p;
					_tmp138_ = _tmp137_->speed;
					_tmp139_ = avg;
					_tmp134_ = _tmp138_ < _tmp139_;
				}
				if (_tmp134_) {
					_tmp133_ = TRUE;
				} else {
					GpxPoint* _tmp140_ = NULL;
					gboolean _tmp141_ = FALSE;
					_tmp140_ = p;
					_tmp141_ = gpx_point_has_position (_tmp140_);
					_tmp133_ = !_tmp141_;
				}
				if (_tmp133_) {
					GpxPoint* _tmp142_ = NULL;
					_tmp142_ = p;
					_tmp142_->stopped = TRUE;
				}
			}
		}
	}
	_tmp143_ = self->filtered_points;
	g_debug ("gpx-parser.vala:221: Removed %i points", _tmp143_);
}


/**
 * This will recalculates all speeds and distances. Call this when the list was modified.
 */
void gpx_track_recalculate (GpxTrack* self) {
	GList* last = NULL;
	g_return_if_fail (self != NULL);
	last = NULL;
	self->total_distance = (gdouble) 0;
	self->max_speed = (gdouble) 0;
	self->max_elevation = 0.0;
	self->min_elevation = 0.0;
	{
		GList* iter = NULL;
		GList* _tmp0_ = NULL;
		GList* _tmp1_ = NULL;
		_tmp0_ = self->points;
		_tmp1_ = g_list_first (_tmp0_);
		iter = _tmp1_;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				GList* _tmp5_ = NULL;
				GpxPoint* point = NULL;
				GList* _tmp6_ = NULL;
				gconstpointer _tmp7_ = NULL;
				GList* _tmp8_ = NULL;
				gdouble radius = 0.0;
				gdouble elevation_value = 0.0;
				GpxPoint* _tmp49_ = NULL;
				gdouble _tmp50_ = 0.0;
				gdouble _tmp51_ = 0.0;
				gdouble weights = 0.0;
				gdouble _tmp52_ = 0.0;
				GList* env_iter = NULL;
				GList* _tmp53_ = NULL;
				gint i = 0;
				GList* _tmp73_ = NULL;
				GpxPoint* _tmp93_ = NULL;
				gdouble _tmp94_ = 0.0;
				gdouble _tmp95_ = 0.0;
				GpxPoint* _tmp96_ = NULL;
				gboolean _tmp97_ = FALSE;
				if (!_tmp2_) {
					GList* _tmp3_ = NULL;
					GList* _tmp4_ = NULL;
					_tmp3_ = iter;
					_tmp4_ = _tmp3_->next;
					iter = _tmp4_;
				}
				_tmp2_ = FALSE;
				_tmp5_ = iter;
				if (!(_tmp5_ != NULL)) {
					break;
				}
				_tmp6_ = iter;
				_tmp7_ = _tmp6_->data;
				point = (GpxPoint*) _tmp7_;
				_tmp8_ = last;
				if (_tmp8_ != NULL) {
					GpxPoint* _tmp9_ = NULL;
					gboolean _tmp10_ = FALSE;
					_tmp9_ = point;
					_tmp10_ = gpx_point_has_position (_tmp9_);
					if (_tmp10_) {
						gdouble _tmp11_ = 0.0;
						GList* _tmp12_ = NULL;
						gconstpointer _tmp13_ = NULL;
						GpxPoint* _tmp14_ = NULL;
						gdouble _tmp15_ = 0.0;
						GpxPoint* _tmp16_ = NULL;
						gdouble _tmp17_ = 0.0;
						GpxPoint* _tmp18_ = NULL;
						GList* _tmp19_ = NULL;
						gconstpointer _tmp20_ = NULL;
						GpxPoint* _tmp21_ = NULL;
						gdouble _tmp22_ = 0.0;
						GpxPoint* _tmp23_ = NULL;
						gdouble _tmp24_ = 0.0;
						gdouble _tmp25_ = 0.0;
						GpxPoint* _tmp28_ = NULL;
						gdouble _tmp29_ = 0.0;
						gdouble _tmp30_ = 0.0;
						GpxPoint* _tmp33_ = NULL;
						gdouble _tmp34_ = 0.0;
						gdouble _tmp35_ = 0.0;
						_tmp11_ = self->total_distance;
						_tmp12_ = last;
						_tmp13_ = _tmp12_->data;
						_tmp14_ = point;
						_tmp15_ = gpx_track_calculate_distance ((GpxPoint*) _tmp13_, _tmp14_);
						self->total_distance = _tmp11_ + _tmp15_;
						_tmp16_ = point;
						_tmp17_ = self->total_distance;
						_tmp16_->distance = _tmp17_;
						_tmp18_ = point;
						_tmp19_ = last;
						_tmp20_ = _tmp19_->data;
						_tmp21_ = point;
						_tmp22_ = gpx_track_calculate_point_to_point_speed (self, (GpxPoint*) _tmp20_, _tmp21_);
						_tmp18_->speed = _tmp22_;
						_tmp23_ = point;
						_tmp24_ = _tmp23_->elevation;
						_tmp25_ = self->max_elevation;
						if (_tmp24_ > _tmp25_) {
							GpxPoint* _tmp26_ = NULL;
							gdouble _tmp27_ = 0.0;
							_tmp26_ = point;
							_tmp27_ = _tmp26_->elevation;
							self->max_elevation = _tmp27_;
						}
						_tmp28_ = point;
						_tmp29_ = _tmp28_->elevation;
						_tmp30_ = self->min_elevation;
						if (_tmp29_ < _tmp30_) {
							GpxPoint* _tmp31_ = NULL;
							gdouble _tmp32_ = 0.0;
							_tmp31_ = point;
							_tmp32_ = _tmp31_->elevation;
							self->min_elevation = _tmp32_;
						}
						_tmp33_ = point;
						_tmp34_ = _tmp33_->speed;
						_tmp35_ = self->max_speed;
						if (_tmp34_ > _tmp35_) {
							GpxPoint* _tmp36_ = NULL;
							gdouble _tmp37_ = 0.0;
							_tmp36_ = point;
							_tmp37_ = _tmp36_->speed;
							self->max_speed = _tmp37_;
						}
					}
				} else {
					GpxPoint* _tmp38_ = NULL;
					gdouble _tmp39_ = 0.0;
					gdouble _tmp40_ = 0.0;
					GpxPoint* _tmp43_ = NULL;
					gdouble _tmp44_ = 0.0;
					gdouble _tmp45_ = 0.0;
					GpxPoint* _tmp48_ = NULL;
					_tmp38_ = point;
					_tmp39_ = _tmp38_->elevation;
					_tmp40_ = self->max_elevation;
					if (_tmp39_ > _tmp40_) {
						GpxPoint* _tmp41_ = NULL;
						gdouble _tmp42_ = 0.0;
						_tmp41_ = point;
						_tmp42_ = _tmp41_->elevation;
						self->max_elevation = _tmp42_;
					}
					_tmp43_ = point;
					_tmp44_ = _tmp43_->elevation;
					_tmp45_ = self->min_elevation;
					if (_tmp44_ < _tmp45_) {
						GpxPoint* _tmp46_ = NULL;
						gdouble _tmp47_ = 0.0;
						_tmp46_ = point;
						_tmp47_ = _tmp46_->elevation;
						self->min_elevation = _tmp47_;
					}
					_tmp48_ = point;
					_tmp48_->distance = (gdouble) 0;
				}
				radius = 0.2;
				_tmp49_ = point;
				_tmp50_ = _tmp49_->elevation;
				_tmp51_ = radius;
				elevation_value = _tmp50_ * _tmp51_;
				_tmp52_ = radius;
				weights = _tmp52_;
				_tmp53_ = iter;
				env_iter = _tmp53_;
				i = 0;
				while (TRUE) {
					GList* _tmp54_ = NULL;
					GList* _tmp55_ = NULL;
					GList* _tmp56_ = NULL;
					gint _tmp57_ = 0;
					gdouble mydist = 0.0;
					GList* _tmp58_ = NULL;
					gconstpointer _tmp59_ = NULL;
					GpxPoint* _tmp60_ = NULL;
					gdouble _tmp61_ = 0.0;
					gdouble _tmp62_ = 0.0;
					gdouble _tmp63_ = 0.0;
					_tmp54_ = env_iter;
					_tmp55_ = _tmp54_->prev;
					env_iter = _tmp55_;
					_tmp56_ = env_iter;
					if (!(_tmp56_ != NULL)) {
						break;
					}
					_tmp57_ = i;
					i = _tmp57_ + 1;
					_tmp58_ = env_iter;
					_tmp59_ = _tmp58_->data;
					_tmp60_ = point;
					_tmp61_ = gpx_track_calculate_distance ((GpxPoint*) _tmp59_, _tmp60_);
					mydist = _tmp61_;
					_tmp62_ = mydist;
					_tmp63_ = radius;
					if (_tmp62_ < _tmp63_) {
						gdouble _tmp64_ = 0.0;
						GList* _tmp65_ = NULL;
						gconstpointer _tmp66_ = NULL;
						gdouble _tmp67_ = 0.0;
						gdouble _tmp68_ = 0.0;
						gdouble _tmp69_ = 0.0;
						gdouble _tmp70_ = 0.0;
						gdouble _tmp71_ = 0.0;
						gdouble _tmp72_ = 0.0;
						_tmp64_ = elevation_value;
						_tmp65_ = env_iter;
						_tmp66_ = _tmp65_->data;
						_tmp67_ = ((GpxPoint*) _tmp66_)->elevation;
						_tmp68_ = radius;
						_tmp69_ = mydist;
						elevation_value = _tmp64_ + (_tmp67_ * (_tmp68_ - _tmp69_));
						_tmp70_ = weights;
						_tmp71_ = radius;
						_tmp72_ = mydist;
						weights = _tmp70_ + (_tmp71_ - _tmp72_);
					} else {
						break;
					}
				}
				_tmp73_ = iter;
				env_iter = _tmp73_;
				while (TRUE) {
					GList* _tmp74_ = NULL;
					GList* _tmp75_ = NULL;
					GList* _tmp76_ = NULL;
					gint _tmp77_ = 0;
					gdouble mydist = 0.0;
					GList* _tmp78_ = NULL;
					gconstpointer _tmp79_ = NULL;
					GpxPoint* _tmp80_ = NULL;
					gdouble _tmp81_ = 0.0;
					gdouble _tmp82_ = 0.0;
					gdouble _tmp83_ = 0.0;
					_tmp74_ = env_iter;
					_tmp75_ = _tmp74_->prev;
					env_iter = _tmp75_;
					_tmp76_ = env_iter;
					if (!(_tmp76_ != NULL)) {
						break;
					}
					_tmp77_ = i;
					i = _tmp77_ + 1;
					_tmp78_ = env_iter;
					_tmp79_ = _tmp78_->data;
					_tmp80_ = point;
					_tmp81_ = gpx_track_calculate_distance ((GpxPoint*) _tmp79_, _tmp80_);
					mydist = _tmp81_;
					_tmp82_ = mydist;
					_tmp83_ = radius;
					if (_tmp82_ < _tmp83_) {
						gdouble _tmp84_ = 0.0;
						GList* _tmp85_ = NULL;
						gconstpointer _tmp86_ = NULL;
						gdouble _tmp87_ = 0.0;
						gdouble _tmp88_ = 0.0;
						gdouble _tmp89_ = 0.0;
						gdouble _tmp90_ = 0.0;
						gdouble _tmp91_ = 0.0;
						gdouble _tmp92_ = 0.0;
						_tmp84_ = elevation_value;
						_tmp85_ = env_iter;
						_tmp86_ = _tmp85_->data;
						_tmp87_ = ((GpxPoint*) _tmp86_)->elevation;
						_tmp88_ = radius;
						_tmp89_ = mydist;
						elevation_value = _tmp84_ + (_tmp87_ * (_tmp88_ - _tmp89_));
						_tmp90_ = weights;
						_tmp91_ = radius;
						_tmp92_ = mydist;
						weights = _tmp90_ + (_tmp91_ - _tmp92_);
					} else {
						break;
					}
				}
				_tmp93_ = point;
				_tmp94_ = elevation_value;
				_tmp95_ = weights;
				_tmp93_->smooth_elevation = _tmp94_ / _tmp95_;
				_tmp96_ = point;
				_tmp97_ = gpx_point_has_position (_tmp96_);
				if (_tmp97_) {
					GList* _tmp98_ = NULL;
					_tmp98_ = iter;
					last = _tmp98_;
				}
			}
		}
	}
}


static gpointer _gpx_point_ref0 (gpointer self) {
	return self ? gpx_point_ref (self) : NULL;
}


void gpx_track_add_point (GpxTrack* self, GpxPoint* point) {
	GpxPoint* _tmp0_ = NULL;
	GpxPoint* _tmp1_ = NULL;
	GpxPoint* _tmp108_ = NULL;
	GpxPoint* _tmp109_ = NULL;
	GpxPoint* _tmp110_ = NULL;
	GpxPoint* _tmp111_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (point != NULL);
	_tmp0_ = point;
	_tmp0_->speed = 0.0;
	_tmp1_ = self->priv->last;
	if (_tmp1_ != NULL) {
		gdouble distance = 0.0;
		GpxPoint* _tmp2_ = NULL;
		GpxPoint* _tmp3_ = NULL;
		gdouble _tmp4_ = 0.0;
		gdouble _tmp5_ = 0.0;
		gdouble _tmp6_ = 0.0;
		GpxPoint* _tmp7_ = NULL;
		gdouble _tmp8_ = 0.0;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp10_ = FALSE;
		GpxPoint* _tmp11_ = NULL;
		gboolean _tmp26_ = FALSE;
		gboolean _tmp27_ = FALSE;
		GpxPoint* _tmp28_ = NULL;
		gboolean _tmp43_ = FALSE;
		gboolean _tmp44_ = FALSE;
		GpxPoint* _tmp45_ = NULL;
		gboolean _tmp60_ = FALSE;
		gboolean _tmp61_ = FALSE;
		GpxPoint* _tmp62_ = NULL;
		gboolean _tmp77_ = FALSE;
		gboolean _tmp78_ = FALSE;
		GpxPoint* _tmp79_ = NULL;
		const gchar* _tmp80_ = NULL;
		_tmp2_ = self->priv->last;
		_tmp3_ = point;
		_tmp4_ = gpx_track_calculate_distance (_tmp2_, _tmp3_);
		distance = _tmp4_;
		_tmp5_ = self->total_distance;
		_tmp6_ = distance;
		self->total_distance = _tmp5_ + _tmp6_;
		_tmp7_ = point;
		_tmp8_ = self->total_distance;
		_tmp7_->distance = _tmp8_;
		_tmp11_ = self->top;
		if (_tmp11_ == NULL) {
			_tmp10_ = TRUE;
		} else {
			GpxPoint* _tmp12_ = NULL;
			gdouble _tmp13_ = 0.0;
			_tmp12_ = self->top;
			_tmp13_ = _tmp12_->lat_dec;
			_tmp10_ = _tmp13_ == ((gdouble) 1000);
		}
		if (_tmp10_) {
			_tmp9_ = TRUE;
		} else {
			GpxPoint* _tmp14_ = NULL;
			gdouble _tmp15_ = 0.0;
			GpxPoint* _tmp16_ = NULL;
			gdouble _tmp17_ = 0.0;
			_tmp14_ = self->top;
			_tmp15_ = _tmp14_->lat_dec;
			_tmp16_ = point;
			_tmp17_ = _tmp16_->lat_dec;
			_tmp9_ = _tmp15_ < _tmp17_;
		}
		if (_tmp9_) {
			GpxPoint* _tmp18_ = NULL;
			GpxPoint* _tmp20_ = NULL;
			GpxPoint* _tmp21_ = NULL;
			gdouble _tmp22_ = 0.0;
			GpxPoint* _tmp23_ = NULL;
			GpxPoint* _tmp24_ = NULL;
			gdouble _tmp25_ = 0.0;
			_tmp18_ = self->top;
			if (_tmp18_ == NULL) {
				GpxPoint* _tmp19_ = NULL;
				_tmp19_ = gpx_point_new ();
				_gpx_point_unref0 (self->top);
				self->top = _tmp19_;
			}
			_tmp20_ = self->top;
			_tmp21_ = point;
			_tmp22_ = _tmp21_->lat_dec;
			_tmp20_->lat_dec = _tmp22_;
			_tmp23_ = self->top;
			_tmp24_ = point;
			_tmp25_ = _tmp24_->lat;
			_tmp23_->lat = _tmp25_;
		}
		_tmp28_ = self->top;
		if (_tmp28_ == NULL) {
			_tmp27_ = TRUE;
		} else {
			GpxPoint* _tmp29_ = NULL;
			gdouble _tmp30_ = 0.0;
			_tmp29_ = self->top;
			_tmp30_ = _tmp29_->lon_dec;
			_tmp27_ = _tmp30_ == ((gdouble) 1000);
		}
		if (_tmp27_) {
			_tmp26_ = TRUE;
		} else {
			GpxPoint* _tmp31_ = NULL;
			gdouble _tmp32_ = 0.0;
			GpxPoint* _tmp33_ = NULL;
			gdouble _tmp34_ = 0.0;
			_tmp31_ = self->top;
			_tmp32_ = _tmp31_->lon_dec;
			_tmp33_ = point;
			_tmp34_ = _tmp33_->lon_dec;
			_tmp26_ = _tmp32_ < _tmp34_;
		}
		if (_tmp26_) {
			GpxPoint* _tmp35_ = NULL;
			GpxPoint* _tmp37_ = NULL;
			GpxPoint* _tmp38_ = NULL;
			gdouble _tmp39_ = 0.0;
			GpxPoint* _tmp40_ = NULL;
			GpxPoint* _tmp41_ = NULL;
			gdouble _tmp42_ = 0.0;
			_tmp35_ = self->top;
			if (_tmp35_ == NULL) {
				GpxPoint* _tmp36_ = NULL;
				_tmp36_ = gpx_point_new ();
				_gpx_point_unref0 (self->top);
				self->top = _tmp36_;
			}
			_tmp37_ = self->top;
			_tmp38_ = point;
			_tmp39_ = _tmp38_->lon_dec;
			_tmp37_->lon_dec = _tmp39_;
			_tmp40_ = self->top;
			_tmp41_ = point;
			_tmp42_ = _tmp41_->lon;
			_tmp40_->lon = _tmp42_;
		}
		_tmp45_ = self->bottom;
		if (_tmp45_ == NULL) {
			_tmp44_ = TRUE;
		} else {
			GpxPoint* _tmp46_ = NULL;
			gdouble _tmp47_ = 0.0;
			_tmp46_ = self->bottom;
			_tmp47_ = _tmp46_->lat_dec;
			_tmp44_ = _tmp47_ == ((gdouble) 1000);
		}
		if (_tmp44_) {
			_tmp43_ = TRUE;
		} else {
			GpxPoint* _tmp48_ = NULL;
			gdouble _tmp49_ = 0.0;
			GpxPoint* _tmp50_ = NULL;
			gdouble _tmp51_ = 0.0;
			_tmp48_ = self->bottom;
			_tmp49_ = _tmp48_->lat_dec;
			_tmp50_ = point;
			_tmp51_ = _tmp50_->lat_dec;
			_tmp43_ = _tmp49_ > _tmp51_;
		}
		if (_tmp43_) {
			GpxPoint* _tmp52_ = NULL;
			GpxPoint* _tmp54_ = NULL;
			GpxPoint* _tmp55_ = NULL;
			gdouble _tmp56_ = 0.0;
			GpxPoint* _tmp57_ = NULL;
			GpxPoint* _tmp58_ = NULL;
			gdouble _tmp59_ = 0.0;
			_tmp52_ = self->bottom;
			if (_tmp52_ == NULL) {
				GpxPoint* _tmp53_ = NULL;
				_tmp53_ = gpx_point_new ();
				_gpx_point_unref0 (self->bottom);
				self->bottom = _tmp53_;
			}
			_tmp54_ = self->bottom;
			_tmp55_ = point;
			_tmp56_ = _tmp55_->lat_dec;
			_tmp54_->lat_dec = _tmp56_;
			_tmp57_ = self->bottom;
			_tmp58_ = point;
			_tmp59_ = _tmp58_->lat;
			_tmp57_->lat = _tmp59_;
		}
		_tmp62_ = self->bottom;
		if (_tmp62_ == NULL) {
			_tmp61_ = TRUE;
		} else {
			GpxPoint* _tmp63_ = NULL;
			gdouble _tmp64_ = 0.0;
			_tmp63_ = self->bottom;
			_tmp64_ = _tmp63_->lon_dec;
			_tmp61_ = _tmp64_ == ((gdouble) 1000);
		}
		if (_tmp61_) {
			_tmp60_ = TRUE;
		} else {
			GpxPoint* _tmp65_ = NULL;
			gdouble _tmp66_ = 0.0;
			GpxPoint* _tmp67_ = NULL;
			gdouble _tmp68_ = 0.0;
			_tmp65_ = self->bottom;
			_tmp66_ = _tmp65_->lon_dec;
			_tmp67_ = point;
			_tmp68_ = _tmp67_->lon_dec;
			_tmp60_ = _tmp66_ > _tmp68_;
		}
		if (_tmp60_) {
			GpxPoint* _tmp69_ = NULL;
			GpxPoint* _tmp71_ = NULL;
			GpxPoint* _tmp72_ = NULL;
			gdouble _tmp73_ = 0.0;
			GpxPoint* _tmp74_ = NULL;
			GpxPoint* _tmp75_ = NULL;
			gdouble _tmp76_ = 0.0;
			_tmp69_ = self->bottom;
			if (_tmp69_ == NULL) {
				GpxPoint* _tmp70_ = NULL;
				_tmp70_ = gpx_point_new ();
				_gpx_point_unref0 (self->bottom);
				self->bottom = _tmp70_;
			}
			_tmp71_ = self->bottom;
			_tmp72_ = point;
			_tmp73_ = _tmp72_->lon_dec;
			_tmp71_->lon_dec = _tmp73_;
			_tmp74_ = self->bottom;
			_tmp75_ = point;
			_tmp76_ = _tmp75_->lon;
			_tmp74_->lon = _tmp76_;
		}
		_tmp79_ = self->priv->last;
		_tmp80_ = _tmp79_->time;
		if (_tmp80_ != NULL) {
			GpxPoint* _tmp81_ = NULL;
			const gchar* _tmp82_ = NULL;
			_tmp81_ = point;
			_tmp82_ = _tmp81_->time;
			_tmp78_ = _tmp82_ != NULL;
		} else {
			_tmp78_ = FALSE;
		}
		if (_tmp78_) {
			GpxPoint* _tmp83_ = NULL;
			gboolean _tmp84_ = FALSE;
			_tmp83_ = point;
			_tmp84_ = gpx_point_has_position (_tmp83_);
			_tmp77_ = _tmp84_;
		} else {
			_tmp77_ = FALSE;
		}
		if (_tmp77_) {
			GpxPoint* _tmp85_ = NULL;
			GpxPoint* _tmp86_ = NULL;
			GpxPoint* _tmp87_ = NULL;
			gdouble _tmp88_ = 0.0;
			GpxPoint* _tmp89_ = NULL;
			gdouble _tmp90_ = 0.0;
			gdouble _tmp91_ = 0.0;
			GpxPoint* _tmp94_ = NULL;
			gdouble _tmp95_ = 0.0;
			gdouble _tmp96_ = 0.0;
			GpxPoint* _tmp99_ = NULL;
			gdouble _tmp100_ = 0.0;
			gdouble _tmp101_ = 0.0;
			_tmp85_ = point;
			_tmp86_ = self->priv->last;
			_tmp87_ = point;
			_tmp88_ = gpx_track_calculate_point_to_point_speed (self, _tmp86_, _tmp87_);
			_tmp85_->speed = _tmp88_;
			_tmp89_ = point;
			_tmp90_ = _tmp89_->speed;
			_tmp91_ = self->max_speed;
			if (_tmp90_ > _tmp91_) {
				GpxPoint* _tmp92_ = NULL;
				gdouble _tmp93_ = 0.0;
				_tmp92_ = point;
				_tmp93_ = _tmp92_->speed;
				self->max_speed = _tmp93_;
			}
			_tmp94_ = point;
			_tmp95_ = _tmp94_->elevation;
			_tmp96_ = self->max_elevation;
			if (_tmp95_ > _tmp96_) {
				GpxPoint* _tmp97_ = NULL;
				gdouble _tmp98_ = 0.0;
				_tmp97_ = point;
				_tmp98_ = _tmp97_->elevation;
				self->max_elevation = _tmp98_;
			}
			_tmp99_ = point;
			_tmp100_ = _tmp99_->elevation;
			_tmp101_ = self->min_elevation;
			if (_tmp100_ < _tmp101_) {
				GpxPoint* _tmp102_ = NULL;
				gdouble _tmp103_ = 0.0;
				_tmp102_ = point;
				_tmp103_ = _tmp102_->elevation;
				self->min_elevation = _tmp103_;
			}
		}
	} else {
		GpxPoint* _tmp104_ = NULL;
		gdouble _tmp105_ = 0.0;
		GpxPoint* _tmp106_ = NULL;
		gdouble _tmp107_ = 0.0;
		_tmp104_ = point;
		_tmp105_ = _tmp104_->elevation;
		self->max_elevation = _tmp105_;
		_tmp106_ = point;
		_tmp107_ = _tmp106_->elevation;
		self->min_elevation = _tmp107_;
	}
	_tmp108_ = point;
	_tmp109_ = _gpx_point_ref0 (_tmp108_);
	self->points = g_list_append (self->points, _tmp109_);
	_tmp110_ = point;
	_tmp111_ = _gpx_point_ref0 (_tmp110_);
	_gpx_point_unref0 (self->priv->last);
	self->priv->last = _tmp111_;
}


GpxTrack* gpx_track_cleanup_speed (GpxTrack* self) {
	GpxTrack* result = NULL;
	GpxTrack* retv = NULL;
	GpxTrack* _tmp0_ = NULL;
	GpxTrack* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	guint num_points = 0U;
	GList* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	gdouble mean = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble deviation = 0.0;
	GList* list_copy = NULL;
	GList* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	GList* iter = NULL;
	GList* _tmp8_ = NULL;
	GList* _tmp9_ = NULL;
	gdouble _tmp20_ = 0.0;
	guint _tmp21_ = 0U;
	GList* _tmp22_ = NULL;
	GList* _tmp23_ = NULL;
	guint i = 0U;
	GList* _tmp94_ = NULL;
	GList* _tmp95_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gpx_track_new ();
	retv = _tmp0_;
	_tmp1_ = retv;
	_tmp2_ = self->priv->_name;
	gpx_track_set_name (_tmp1_, _tmp2_);
	_tmp3_ = self->points;
	_tmp4_ = g_list_length (_tmp3_);
	num_points = _tmp4_;
	_tmp5_ = gpx_track_get_track_average (self);
	mean = _tmp5_;
	deviation = 0.0;
	_tmp6_ = self->points;
	_tmp7_ = g_list_copy (_tmp6_);
	list_copy = _tmp7_;
	_tmp8_ = list_copy;
	_tmp9_ = g_list_first (_tmp8_);
	iter = _tmp9_;
	while (TRUE) {
		GList* _tmp10_ = NULL;
		gdouble diff = 0.0;
		GList* _tmp11_ = NULL;
		gconstpointer _tmp12_ = NULL;
		gdouble _tmp13_ = 0.0;
		gdouble _tmp14_ = 0.0;
		gdouble _tmp15_ = 0.0;
		gdouble _tmp16_ = 0.0;
		gdouble _tmp17_ = 0.0;
		GList* _tmp18_ = NULL;
		GList* _tmp19_ = NULL;
		_tmp10_ = iter;
		if (!(_tmp10_ != NULL)) {
			break;
		}
		_tmp11_ = iter;
		_tmp12_ = _tmp11_->data;
		_tmp13_ = ((GpxPoint*) _tmp12_)->speed;
		_tmp14_ = mean;
		diff = _tmp13_ - _tmp14_;
		_tmp15_ = deviation;
		_tmp16_ = diff;
		_tmp17_ = diff;
		deviation = _tmp15_ + (_tmp16_ * _tmp17_);
		_tmp18_ = iter;
		_tmp19_ = _tmp18_->next;
		iter = _tmp19_;
	}
	_tmp20_ = deviation;
	_tmp21_ = num_points;
	deviation = _tmp20_ / _tmp21_;
	_tmp22_ = list_copy;
	_tmp23_ = g_list_first (_tmp22_);
	iter = _tmp23_;
	i = (guint) 0;
	while (TRUE) {
		GList* _tmp24_ = NULL;
		gdouble pspeed = 0.0;
		GList* _tmp25_ = NULL;
		gconstpointer _tmp26_ = NULL;
		gdouble _tmp27_ = 0.0;
		GList* _tmp28_ = NULL;
		GList* _tmp29_ = NULL;
		gdouble pdf = 0.0;
		gdouble _tmp34_ = 0.0;
		gdouble _tmp35_ = 0.0;
		gdouble _tmp36_ = 0.0;
		gdouble _tmp37_ = 0.0;
		gdouble _tmp38_ = 0.0;
		gdouble _tmp39_ = 0.0;
		gdouble _tmp40_ = 0.0;
		gdouble _tmp41_ = 0.0;
		gboolean _tmp42_ = FALSE;
		guint _tmp43_ = 0U;
		gdouble _tmp44_ = 0.0;
		_tmp24_ = iter;
		if (!(_tmp24_ != NULL)) {
			break;
		}
		_tmp25_ = iter;
		_tmp26_ = _tmp25_->data;
		_tmp27_ = ((GpxPoint*) _tmp26_)->speed;
		pspeed = _tmp27_;
		_tmp28_ = iter;
		_tmp29_ = _tmp28_->next;
		if (_tmp29_ != NULL) {
			GList* _tmp30_ = NULL;
			GList* _tmp31_ = NULL;
			gconstpointer _tmp32_ = NULL;
			gdouble _tmp33_ = 0.0;
			_tmp30_ = iter;
			_tmp31_ = _tmp30_->next;
			_tmp32_ = _tmp31_->data;
			_tmp33_ = ((GpxPoint*) _tmp32_)->speed;
			pspeed = _tmp33_;
		}
		_tmp34_ = deviation;
		_tmp35_ = sqrt ((2 * G_PI) * _tmp34_);
		_tmp36_ = pspeed;
		_tmp37_ = mean;
		_tmp38_ = pspeed;
		_tmp39_ = mean;
		_tmp40_ = deviation;
		_tmp41_ = exp ((-((_tmp36_ - _tmp37_) * (_tmp38_ - _tmp39_))) / (2 * _tmp40_));
		pdf = (1 / _tmp35_) * _tmp41_;
		_tmp43_ = num_points;
		_tmp44_ = pdf;
		if ((_tmp43_ * _tmp44_) < 0.1) {
			GList* _tmp45_ = NULL;
			gconstpointer _tmp46_ = NULL;
			gboolean _tmp47_ = FALSE;
			_tmp45_ = iter;
			_tmp46_ = _tmp45_->data;
			_tmp47_ = ((GpxPoint*) _tmp46_)->stopped;
			_tmp42_ = !_tmp47_;
		} else {
			_tmp42_ = FALSE;
		}
		if (_tmp42_) {
			GList* temp = NULL;
			GList* _tmp48_ = NULL;
			GList* _tmp49_ = NULL;
			GList* _tmp50_ = NULL;
			GList* _tmp51_ = NULL;
			_tmp48_ = iter;
			_tmp49_ = _tmp48_->prev;
			temp = _tmp49_;
			_tmp50_ = iter;
			list_copy = g_list_remove_link (list_copy, _tmp50_);
			_tmp51_ = temp;
			if (_tmp51_ != NULL) {
				GList* _tmp52_ = NULL;
				GList* _tmp53_ = NULL;
				GList* _tmp54_ = NULL;
				_tmp52_ = temp;
				iter = _tmp52_;
				_tmp53_ = iter;
				_tmp54_ = _tmp53_->next;
				if (_tmp54_ != NULL) {
					GList* _tmp55_ = NULL;
					GList* _tmp56_ = NULL;
					gconstpointer _tmp57_ = NULL;
					GList* _tmp58_ = NULL;
					gconstpointer _tmp59_ = NULL;
					GList* _tmp60_ = NULL;
					GList* _tmp61_ = NULL;
					gconstpointer _tmp62_ = NULL;
					gdouble _tmp63_ = 0.0;
					_tmp55_ = iter;
					_tmp56_ = _tmp55_->next;
					_tmp57_ = _tmp56_->data;
					_tmp58_ = iter;
					_tmp59_ = _tmp58_->data;
					_tmp60_ = iter;
					_tmp61_ = _tmp60_->next;
					_tmp62_ = _tmp61_->data;
					_tmp63_ = gpx_track_calculate_point_to_point_speed (self, (GpxPoint*) _tmp59_, (GpxPoint*) _tmp62_);
					((GpxPoint*) _tmp57_)->speed = _tmp63_;
				}
			} else {
				GList* _tmp64_ = NULL;
				GList* _tmp65_ = NULL;
				GList* _tmp66_ = NULL;
				i = (guint) 0;
				_tmp64_ = list_copy;
				_tmp65_ = g_list_first (_tmp64_);
				iter = _tmp65_;
				_tmp66_ = iter;
				if (_tmp66_ != NULL) {
					GList* _tmp67_ = NULL;
					gconstpointer _tmp68_ = NULL;
					GList* _tmp69_ = NULL;
					gconstpointer _tmp70_ = NULL;
					GList* _tmp71_ = NULL;
					GList* _tmp72_ = NULL;
					_tmp67_ = iter;
					_tmp68_ = _tmp67_->data;
					((GpxPoint*) _tmp68_)->speed = 0.0;
					_tmp69_ = iter;
					_tmp70_ = _tmp69_->data;
					((GpxPoint*) _tmp70_)->distance = 0.0;
					_tmp71_ = iter;
					_tmp72_ = _tmp71_->next;
					if (_tmp72_ != NULL) {
						GList* _tmp73_ = NULL;
						GList* _tmp74_ = NULL;
						gconstpointer _tmp75_ = NULL;
						GList* _tmp76_ = NULL;
						gconstpointer _tmp77_ = NULL;
						GList* _tmp78_ = NULL;
						GList* _tmp79_ = NULL;
						gconstpointer _tmp80_ = NULL;
						gdouble _tmp81_ = 0.0;
						GList* _tmp82_ = NULL;
						GList* _tmp83_ = NULL;
						gconstpointer _tmp84_ = NULL;
						GList* _tmp85_ = NULL;
						gconstpointer _tmp86_ = NULL;
						GList* _tmp87_ = NULL;
						GList* _tmp88_ = NULL;
						gconstpointer _tmp89_ = NULL;
						gdouble _tmp90_ = 0.0;
						_tmp73_ = iter;
						_tmp74_ = _tmp73_->next;
						_tmp75_ = _tmp74_->data;
						_tmp76_ = iter;
						_tmp77_ = _tmp76_->data;
						_tmp78_ = iter;
						_tmp79_ = _tmp78_->next;
						_tmp80_ = _tmp79_->data;
						_tmp81_ = gpx_track_calculate_distance ((GpxPoint*) _tmp77_, (GpxPoint*) _tmp80_);
						((GpxPoint*) _tmp75_)->distance = _tmp81_;
						_tmp82_ = iter;
						_tmp83_ = _tmp82_->next;
						_tmp84_ = _tmp83_->data;
						_tmp85_ = iter;
						_tmp86_ = _tmp85_->data;
						_tmp87_ = iter;
						_tmp88_ = _tmp87_->next;
						_tmp89_ = _tmp88_->data;
						_tmp90_ = gpx_track_calculate_point_to_point_speed (self, (GpxPoint*) _tmp86_, (GpxPoint*) _tmp89_);
						((GpxPoint*) _tmp84_)->speed = _tmp90_;
					}
				}
			}
		} else {
			GList* _tmp91_ = NULL;
			GList* _tmp92_ = NULL;
			guint _tmp93_ = 0U;
			_tmp91_ = iter;
			_tmp92_ = _tmp91_->next;
			iter = _tmp92_;
			_tmp93_ = i;
			i = _tmp93_ + 1;
		}
	}
	_tmp94_ = list_copy;
	_tmp95_ = g_list_first (_tmp94_);
	iter = _tmp95_;
	while (TRUE) {
		GList* _tmp96_ = NULL;
		GpxTrack* _tmp97_ = NULL;
		GList* _tmp98_ = NULL;
		gconstpointer _tmp99_ = NULL;
		GList* _tmp100_ = NULL;
		GList* _tmp101_ = NULL;
		_tmp96_ = iter;
		if (!(_tmp96_ != NULL)) {
			break;
		}
		_tmp97_ = retv;
		_tmp98_ = iter;
		_tmp99_ = _tmp98_->data;
		gpx_track_add_point (_tmp97_, (GpxPoint*) _tmp99_);
		_tmp100_ = iter;
		_tmp101_ = _tmp100_->next;
		iter = _tmp101_;
	}
	result = retv;
	_g_list_free0 (list_copy);
	return result;
}


/**
         * Calculate the speed of the full track
         *
         * @returns the average speed of the full track in km/h.
         */
gdouble gpx_track_get_track_average (GpxTrack* self) {
	gdouble result = 0.0;
	GList* first = NULL;
	GList* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	GList* last = NULL;
	GList* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GList* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->points;
	_tmp1_ = g_list_first (_tmp0_);
	first = _tmp1_;
	_tmp2_ = self->points;
	_tmp3_ = g_list_last (_tmp2_);
	last = _tmp3_;
	_tmp5_ = first;
	if (_tmp5_ != NULL) {
		GList* _tmp6_ = NULL;
		_tmp6_ = last;
		_tmp4_ = _tmp6_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		GList* _tmp7_ = NULL;
		gconstpointer _tmp8_ = NULL;
		GList* _tmp9_ = NULL;
		gconstpointer _tmp10_ = NULL;
		gdouble _tmp11_ = 0.0;
		_tmp7_ = first;
		_tmp8_ = _tmp7_->data;
		_tmp9_ = last;
		_tmp10_ = _tmp9_->data;
		_tmp11_ = gpx_track_calculate_point_to_point_speed (self, (GpxPoint*) _tmp8_, (GpxPoint*) _tmp10_);
		result = _tmp11_;
		return result;
	}
	result = (gdouble) 0;
	return result;
}


/**
         * Calculate the average speed between Point a and Point b on the track
         */
gdouble gpx_track_calculate_point_to_point_speed (GpxTrack* self, GpxPoint* a, GpxPoint* b) {
	gdouble result = 0.0;
	gdouble dist = 0.0;
	GpxPoint* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	GpxPoint* _tmp2_ = NULL;
	gdouble _tmp3_ = 0.0;
	gboolean _tmp4_ = FALSE;
	GpxPoint* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	time_t ta = 0;
	GpxPoint* _tmp9_ = NULL;
	time_t _tmp10_ = 0;
	time_t tb = 0;
	GpxPoint* _tmp11_ = NULL;
	time_t _tmp12_ = 0;
	time_t _tmp13_ = 0;
	time_t _tmp14_ = 0;
	gdouble speed = 0.0;
	gdouble _tmp15_ = 0.0;
	time_t _tmp16_ = 0;
	time_t _tmp17_ = 0;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (a != NULL, 0.0);
	g_return_val_if_fail (b != NULL, 0.0);
	_tmp0_ = b;
	_tmp1_ = _tmp0_->distance;
	_tmp2_ = a;
	_tmp3_ = _tmp2_->distance;
	dist = _tmp1_ - _tmp3_;
	_tmp5_ = a;
	_tmp6_ = _tmp5_->time;
	if (_tmp6_ == NULL) {
		_tmp4_ = TRUE;
	} else {
		GpxPoint* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		_tmp7_ = b;
		_tmp8_ = _tmp7_->time;
		_tmp4_ = _tmp8_ == NULL;
	}
	if (_tmp4_) {
		result = (gdouble) 0;
		return result;
	}
	_tmp9_ = a;
	_tmp10_ = gpx_point_get_time (_tmp9_);
	ta = _tmp10_;
	_tmp11_ = b;
	_tmp12_ = gpx_point_get_time (_tmp11_);
	tb = _tmp12_;
	_tmp13_ = tb;
	_tmp14_ = ta;
	if ((_tmp13_ - _tmp14_) == ((time_t) 0)) {
		result = (gdouble) 0;
		return result;
	}
	_tmp15_ = dist;
	_tmp16_ = tb;
	_tmp17_ = ta;
	speed = ((60.0 * 60.0) * _tmp15_) / (_tmp16_ - _tmp17_);
	result = speed;
	return result;
}


time_t gpx_track_get_total_time (GpxTrack* self) {
	time_t result = 0;
	GpxPoint* a = NULL;
	GpxPoint* b = NULL;
	GList* na = NULL;
	GList* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	GList* nb = NULL;
	GList* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GList* _tmp5_ = NULL;
	GList* _tmp7_ = NULL;
	gconstpointer _tmp8_ = NULL;
	GpxPoint* _tmp9_ = NULL;
	GList* _tmp10_ = NULL;
	gconstpointer _tmp11_ = NULL;
	GpxPoint* _tmp12_ = NULL;
	time_t time = 0;
	GpxPoint* _tmp13_ = NULL;
	time_t _tmp14_ = 0;
	GpxPoint* _tmp15_ = NULL;
	time_t _tmp16_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->points;
	_tmp1_ = g_list_first (_tmp0_);
	na = _tmp1_;
	_tmp2_ = self->points;
	_tmp3_ = g_list_last (_tmp2_);
	nb = _tmp3_;
	_tmp5_ = na;
	if (_tmp5_ == NULL) {
		_tmp4_ = TRUE;
	} else {
		GList* _tmp6_ = NULL;
		_tmp6_ = nb;
		_tmp4_ = _tmp6_ == NULL;
	}
	if (_tmp4_) {
		result = (time_t) 0;
		_gpx_point_unref0 (b);
		_gpx_point_unref0 (a);
		return result;
	}
	_tmp7_ = na;
	_tmp8_ = _tmp7_->data;
	_tmp9_ = _gpx_point_ref0 ((GpxPoint*) _tmp8_);
	_gpx_point_unref0 (a);
	a = _tmp9_;
	_tmp10_ = nb;
	_tmp11_ = _tmp10_->data;
	_tmp12_ = _gpx_point_ref0 ((GpxPoint*) _tmp11_);
	_gpx_point_unref0 (b);
	b = _tmp12_;
	_tmp13_ = b;
	_tmp14_ = gpx_point_get_time (_tmp13_);
	_tmp15_ = a;
	_tmp16_ = gpx_point_get_time (_tmp15_);
	time = _tmp14_ - _tmp16_;
	result = time;
	_gpx_point_unref0 (b);
	_gpx_point_unref0 (a);
	return result;
}


/**
         * Try not to calculate time that we "stopped"  in average
         */
gdouble gpx_track_calculate_moving_average (GpxTrack* self, GpxPoint* start, GpxPoint* stop, time_t* moving_time) {
	time_t _vala_moving_time = 0;
	gdouble result = 0.0;
	gdouble time = 0.0;
	gdouble distance = 0.0;
	GList* iter = NULL;
	GList* _tmp0_ = NULL;
	GpxPoint* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	gdouble _tmp32_ = 0.0;
	gdouble _tmp33_ = 0.0;
	gdouble _tmp34_ = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (start != NULL, 0.0);
	g_return_val_if_fail (stop != NULL, 0.0);
	time = (gdouble) 0;
	distance = (gdouble) 0;
	_vala_moving_time = (time_t) 0;
	_tmp0_ = self->points;
	_tmp1_ = start;
	_tmp2_ = g_list_find (_tmp0_, _tmp1_);
	iter = _tmp2_;
	_tmp3_ = iter;
	if (_tmp3_ == NULL) {
		result = (gdouble) 0;
		if (moving_time) {
			*moving_time = _vala_moving_time;
		}
		return result;
	}
	_tmp4_ = iter;
	if (_tmp4_ != NULL) {
		while (TRUE) {
			gboolean _tmp5_ = FALSE;
			GList* _tmp6_ = NULL;
			GList* _tmp7_ = NULL;
			GList* _tmp8_ = NULL;
			GpxPoint* b = NULL;
			GList* _tmp13_ = NULL;
			gconstpointer _tmp14_ = NULL;
			GpxPoint* _tmp15_ = NULL;
			GpxPoint* _tmp16_ = NULL;
			gboolean _tmp17_ = FALSE;
			_tmp6_ = iter;
			_tmp7_ = _tmp6_->next;
			iter = _tmp7_;
			_tmp8_ = iter;
			if (_tmp8_ != NULL) {
				GList* _tmp9_ = NULL;
				GList* _tmp10_ = NULL;
				gconstpointer _tmp11_ = NULL;
				GpxPoint* _tmp12_ = NULL;
				_tmp9_ = iter;
				_tmp10_ = _tmp9_->prev;
				_tmp11_ = _tmp10_->data;
				_tmp12_ = stop;
				_tmp5_ = ((GpxPoint*) _tmp11_) != _tmp12_;
			} else {
				_tmp5_ = FALSE;
			}
			if (!_tmp5_) {
				break;
			}
			_tmp13_ = iter;
			_tmp14_ = _tmp13_->data;
			_tmp15_ = _gpx_point_ref0 ((GpxPoint*) _tmp14_);
			b = _tmp15_;
			_tmp16_ = b;
			_tmp17_ = _tmp16_->stopped;
			if (!_tmp17_) {
				gdouble _tmp18_ = 0.0;
				GpxPoint* _tmp19_ = NULL;
				time_t _tmp20_ = 0;
				GList* _tmp21_ = NULL;
				GList* _tmp22_ = NULL;
				gconstpointer _tmp23_ = NULL;
				time_t _tmp24_ = 0;
				gdouble _tmp25_ = 0.0;
				GpxPoint* _tmp26_ = NULL;
				gdouble _tmp27_ = 0.0;
				GList* _tmp28_ = NULL;
				GList* _tmp29_ = NULL;
				gconstpointer _tmp30_ = NULL;
				gdouble _tmp31_ = 0.0;
				_tmp18_ = time;
				_tmp19_ = b;
				_tmp20_ = gpx_point_get_time (_tmp19_);
				_tmp21_ = iter;
				_tmp22_ = _tmp21_->prev;
				_tmp23_ = _tmp22_->data;
				_tmp24_ = gpx_point_get_time ((GpxPoint*) _tmp23_);
				time = _tmp18_ + (_tmp20_ - _tmp24_);
				_tmp25_ = distance;
				_tmp26_ = b;
				_tmp27_ = _tmp26_->distance;
				_tmp28_ = iter;
				_tmp29_ = _tmp28_->prev;
				_tmp30_ = _tmp29_->data;
				_tmp31_ = ((GpxPoint*) _tmp30_)->distance;
				distance = _tmp25_ + (_tmp27_ - _tmp31_);
			}
			_gpx_point_unref0 (b);
		}
	}
	_tmp32_ = time;
	_vala_moving_time = (time_t) _tmp32_;
	_tmp33_ = distance;
	_tmp34_ = time;
	result = _tmp33_ / (_tmp34_ / (60.0 * 60.0));
	if (moving_time) {
		*moving_time = _vala_moving_time;
	}
	return result;
}


void gpx_track_calculate_total_elevation (GpxTrack* self, GpxPoint* start, GpxPoint* stop, gdouble* up, gdouble* down) {
	gdouble _vala_up = 0.0;
	gdouble _vala_down = 0.0;
	GList* iter = NULL;
	GList* _tmp0_ = NULL;
	GpxPoint* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	GList* last = NULL;
	GList* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (start != NULL);
	g_return_if_fail (stop != NULL);
	_vala_up = 0.0;
	_vala_down = 0.0;
	_tmp0_ = self->points;
	_tmp1_ = start;
	_tmp2_ = g_list_find (_tmp0_, _tmp1_);
	iter = _tmp2_;
	last = NULL;
	_tmp3_ = iter;
	if (_tmp3_ == NULL) {
		if (up) {
			*up = _vala_up;
		}
		if (down) {
			*down = _vala_down;
		}
		return;
	}
	{
		gboolean _tmp4_ = FALSE;
		_tmp4_ = TRUE;
		while (TRUE) {
			GList* _tmp13_ = NULL;
			GList* _tmp34_ = NULL;
			if (!_tmp4_) {
				gboolean _tmp5_ = FALSE;
				GList* _tmp6_ = NULL;
				GList* _tmp7_ = NULL;
				GList* _tmp8_ = NULL;
				_tmp6_ = iter;
				_tmp7_ = _tmp6_->next;
				iter = _tmp7_;
				_tmp8_ = iter;
				if (_tmp8_ != NULL) {
					GList* _tmp9_ = NULL;
					GList* _tmp10_ = NULL;
					gconstpointer _tmp11_ = NULL;
					GpxPoint* _tmp12_ = NULL;
					_tmp9_ = iter;
					_tmp10_ = _tmp9_->prev;
					_tmp11_ = _tmp10_->data;
					_tmp12_ = stop;
					_tmp5_ = ((GpxPoint*) _tmp11_) != _tmp12_;
				} else {
					_tmp5_ = FALSE;
				}
				if (!_tmp5_) {
					break;
				}
			}
			_tmp4_ = FALSE;
			_tmp13_ = last;
			if (_tmp13_ != NULL) {
				GList* _tmp14_ = NULL;
				gconstpointer _tmp15_ = NULL;
				gdouble _tmp16_ = 0.0;
				GList* _tmp17_ = NULL;
				gconstpointer _tmp18_ = NULL;
				gdouble _tmp19_ = 0.0;
				_tmp14_ = iter;
				_tmp15_ = _tmp14_->data;
				_tmp16_ = ((GpxPoint*) _tmp15_)->smooth_elevation;
				_tmp17_ = last;
				_tmp18_ = _tmp17_->data;
				_tmp19_ = ((GpxPoint*) _tmp18_)->smooth_elevation;
				if (_tmp16_ > _tmp19_) {
					gdouble _tmp20_ = 0.0;
					GList* _tmp21_ = NULL;
					gconstpointer _tmp22_ = NULL;
					gdouble _tmp23_ = 0.0;
					GList* _tmp24_ = NULL;
					gconstpointer _tmp25_ = NULL;
					gdouble _tmp26_ = 0.0;
					_tmp20_ = _vala_up;
					_tmp21_ = iter;
					_tmp22_ = _tmp21_->data;
					_tmp23_ = ((GpxPoint*) _tmp22_)->smooth_elevation;
					_tmp24_ = last;
					_tmp25_ = _tmp24_->data;
					_tmp26_ = ((GpxPoint*) _tmp25_)->smooth_elevation;
					_vala_up = _tmp20_ + (_tmp23_ - _tmp26_);
				} else {
					gdouble _tmp27_ = 0.0;
					GList* _tmp28_ = NULL;
					gconstpointer _tmp29_ = NULL;
					gdouble _tmp30_ = 0.0;
					GList* _tmp31_ = NULL;
					gconstpointer _tmp32_ = NULL;
					gdouble _tmp33_ = 0.0;
					_tmp27_ = _vala_down;
					_tmp28_ = last;
					_tmp29_ = _tmp28_->data;
					_tmp30_ = ((GpxPoint*) _tmp29_)->smooth_elevation;
					_tmp31_ = iter;
					_tmp32_ = _tmp31_->data;
					_tmp33_ = ((GpxPoint*) _tmp32_)->smooth_elevation;
					_vala_down = _tmp27_ + (_tmp30_ - _tmp33_);
				}
			}
			_tmp34_ = iter;
			last = _tmp34_;
		}
	}
	if (up) {
		*up = _vala_up;
	}
	if (down) {
		*down = _vala_down;
	}
}


/**
 * @param lon_a longitude in radians of point a
 * @param lat_a latitude in radians of point a
 * @param lon_b longitude in radians of point b
 * @param lat_a latitude in radians of point b
         * Calculate distance between point a and point b using great circular distance method
         * Elevation is not taken into account.
         *
         * @returns distance in km.		 
 */
gdouble gpx_track_calculate_distance_coords (gdouble lon_a, gdouble lat_a, gdouble lon_b, gdouble lat_b) {
	gdouble result = 0.0;
	gdouble retv = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gint _tmp13_ = 0;
	retv = (gdouble) 0;
	_tmp0_ = lat_a;
	_tmp1_ = sin (_tmp0_);
	_tmp2_ = lat_b;
	_tmp3_ = sin (_tmp2_);
	_tmp4_ = lat_a;
	_tmp5_ = cos (_tmp4_);
	_tmp6_ = lat_b;
	_tmp7_ = cos (_tmp6_);
	_tmp8_ = lon_b;
	_tmp9_ = lon_a;
	_tmp10_ = cos (_tmp8_ - _tmp9_);
	_tmp11_ = acos ((_tmp1_ * _tmp3_) + ((_tmp5_ * _tmp7_) * _tmp10_));
	retv = 6378.7 * _tmp11_;
	_tmp12_ = retv;
	_tmp13_ = isnan (_tmp12_);
	if (_tmp13_ == 1) {
		result = (gdouble) 0;
		return result;
	}
	result = retv;
	return result;
}


/**
         * @param a the first Gpx.Point
         * @param b the second Gpx.Point
         *
         * Calculate distance between point a and point b using great circular distance method
         * Elevation is not taken into account.
         *
         * @returns distance in km.
         */
gdouble gpx_track_calculate_distance (GpxPoint* a, GpxPoint* b) {
	gdouble result = 0.0;
	gboolean _tmp0_ = FALSE;
	GpxPoint* _tmp1_ = NULL;
	gdouble _tmp2_ = 0.0;
	GpxPoint* _tmp3_ = NULL;
	gdouble _tmp4_ = 0.0;
	GpxPoint* _tmp9_ = NULL;
	gdouble _tmp10_ = 0.0;
	GpxPoint* _tmp11_ = NULL;
	gdouble _tmp12_ = 0.0;
	GpxPoint* _tmp13_ = NULL;
	gdouble _tmp14_ = 0.0;
	GpxPoint* _tmp15_ = NULL;
	gdouble _tmp16_ = 0.0;
	gdouble _tmp17_ = 0.0;
	g_return_val_if_fail (a != NULL, 0.0);
	g_return_val_if_fail (b != NULL, 0.0);
	_tmp1_ = a;
	_tmp2_ = _tmp1_->lat;
	_tmp3_ = b;
	_tmp4_ = _tmp3_->lat;
	if (_tmp2_ == _tmp4_) {
		GpxPoint* _tmp5_ = NULL;
		gdouble _tmp6_ = 0.0;
		GpxPoint* _tmp7_ = NULL;
		gdouble _tmp8_ = 0.0;
		_tmp5_ = a;
		_tmp6_ = _tmp5_->lon;
		_tmp7_ = b;
		_tmp8_ = _tmp7_->lon;
		_tmp0_ = _tmp6_ == _tmp8_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = (gdouble) 0;
		return result;
	}
	_tmp9_ = a;
	_tmp10_ = _tmp9_->lon;
	_tmp11_ = a;
	_tmp12_ = _tmp11_->lat;
	_tmp13_ = b;
	_tmp14_ = _tmp13_->lon;
	_tmp15_ = b;
	_tmp16_ = _tmp15_->lat;
	_tmp17_ = gpx_track_calculate_distance_coords (_tmp10_, _tmp12_, _tmp14_, _tmp16_);
	result = _tmp17_;
	return result;
}


guint gpx_track_heartrate_avg (GpxTrack* self, GpxPoint* start, GpxPoint* stop) {
	guint result = 0U;
	gdouble total = 0.0;
	gdouble total_time = 0.0;
	GpxPoint* prev = NULL;
	GList* iter = NULL;
	GList* _tmp0_ = NULL;
	GpxPoint* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	guint _tmp33_ = 0U;
	gdouble _tmp34_ = 0.0;
	g_return_val_if_fail (self != NULL, 0U);
	g_return_val_if_fail (start != NULL, 0U);
	g_return_val_if_fail (stop != NULL, 0U);
	total = (gdouble) 0;
	total_time = 0.0;
	prev = NULL;
	_tmp0_ = self->points;
	_tmp1_ = start;
	_tmp2_ = g_list_find (_tmp0_, _tmp1_);
	iter = _tmp2_;
	_tmp3_ = iter;
	if (_tmp3_ == NULL) {
		result = (guint) 0;
		return result;
	}
	{
		gboolean _tmp4_ = FALSE;
		_tmp4_ = TRUE;
		while (TRUE) {
			GpxPoint* p = NULL;
			GList* _tmp11_ = NULL;
			gconstpointer _tmp12_ = NULL;
			GpxPoint* _tmp13_ = NULL;
			GpxPoint* _tmp14_ = NULL;
			GpxHeartRateMonitorPoint _tmp15_ = {0};
			gint _tmp16_ = 0;
			GList* _tmp31_ = NULL;
			GList* _tmp32_ = NULL;
			if (!_tmp4_) {
				gboolean _tmp5_ = FALSE;
				GList* _tmp6_ = NULL;
				_tmp6_ = iter;
				if (_tmp6_ != NULL) {
					GList* _tmp7_ = NULL;
					GList* _tmp8_ = NULL;
					gconstpointer _tmp9_ = NULL;
					GpxPoint* _tmp10_ = NULL;
					_tmp7_ = iter;
					_tmp8_ = _tmp7_->prev;
					_tmp9_ = _tmp8_->data;
					_tmp10_ = stop;
					_tmp5_ = ((GpxPoint*) _tmp9_) != _tmp10_;
				} else {
					_tmp5_ = FALSE;
				}
				if (!_tmp5_) {
					break;
				}
			}
			_tmp4_ = FALSE;
			_tmp11_ = iter;
			_tmp12_ = _tmp11_->data;
			_tmp13_ = _gpx_point_ref0 ((GpxPoint*) _tmp12_);
			p = _tmp13_;
			_tmp14_ = p;
			_tmp15_ = _tmp14_->tpe;
			_tmp16_ = _tmp15_.heartrate;
			if (_tmp16_ != 0) {
				GpxPoint* _tmp17_ = NULL;
				_tmp17_ = prev;
				if (_tmp17_ == NULL) {
					GpxPoint* _tmp18_ = NULL;
					_tmp18_ = p;
					prev = _tmp18_;
				} else {
					gdouble diff = 0.0;
					GpxPoint* _tmp19_ = NULL;
					time_t _tmp20_ = 0;
					GpxPoint* _tmp21_ = NULL;
					time_t _tmp22_ = 0;
					GpxPoint* _tmp30_ = NULL;
					_tmp19_ = p;
					_tmp20_ = gpx_point_get_time (_tmp19_);
					_tmp21_ = prev;
					_tmp22_ = gpx_point_get_time (_tmp21_);
					diff = ((gdouble) _tmp20_) - ((gdouble) _tmp22_);
					{
						gdouble _tmp23_ = 0.0;
						GpxPoint* _tmp24_ = NULL;
						GpxHeartRateMonitorPoint _tmp25_ = {0};
						gint _tmp26_ = 0;
						gdouble _tmp27_ = 0.0;
						gdouble _tmp28_ = 0.0;
						gdouble _tmp29_ = 0.0;
						_tmp23_ = total;
						_tmp24_ = prev;
						_tmp25_ = _tmp24_->tpe;
						_tmp26_ = _tmp25_.heartrate;
						_tmp27_ = diff;
						total = _tmp23_ + (_tmp26_ * _tmp27_);
						_tmp28_ = total_time;
						_tmp29_ = diff;
						total_time = _tmp28_ + _tmp29_;
					}
					_tmp30_ = p;
					prev = _tmp30_;
				}
			}
			_tmp31_ = iter;
			_tmp32_ = _tmp31_->next;
			iter = _tmp32_;
			_gpx_point_unref0 (p);
		}
	}
	_tmp34_ = total_time;
	if (_tmp34_ > ((gdouble) 0)) {
		gdouble _tmp35_ = 0.0;
		gdouble _tmp36_ = 0.0;
		_tmp35_ = total;
		_tmp36_ = total_time;
		_tmp33_ = (guint) (_tmp35_ / _tmp36_);
	} else {
		_tmp33_ = (guint) 0;
	}
	result = _tmp33_;
	return result;
}


guint gpx_track_get_burned_calories (GpxTrack* self) {
	guint result = 0U;
	GpxHeartRateMonitorTrack _tmp0_ = {0};
	guint32 _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->hrmt;
	_tmp1_ = _tmp0_.calories;
	result = (guint) _tmp1_;
	return result;
}


void gpx_track_set_burned_calories (GpxTrack* self, guint value) {
	guint _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->hrmt.calories = (guint32) _tmp0_;
}


GpxTrack* gpx_track_construct (GType object_type) {
	GpxTrack * self = NULL;
	self = (GpxTrack*) g_object_new (object_type, NULL);
	return self;
}


GpxTrack* gpx_track_new (void) {
	return gpx_track_construct (GPX_TYPE_TRACK);
}


const gchar* gpx_track_get_name (GpxTrack* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}


void gpx_track_set_name (GpxTrack* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp1_;
	g_object_notify ((GObject *) self, "name");
}


static void gpx_track_class_init (GpxTrackClass * klass) {
	gpx_track_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GpxTrackPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gpx_track_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gpx_track_set_property;
	G_OBJECT_CLASS (klass)->finalize = gpx_track_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GPX_TRACK_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void gpx_track_instance_init (GpxTrack * self) {
	GpxHeartRateMonitorTrack _tmp0_ = {0};
	self->priv = GPX_TRACK_GET_PRIVATE (self);
	memset (&_tmp0_, 0, sizeof (GpxHeartRateMonitorTrack));
	_tmp0_.calories = (guint32) 0;
	self->hrmt = _tmp0_;
	self->priv->_name = NULL;
	self->filtered_points = 0;
	self->total_distance = 0.0;
	self->max_speed = 0.0;
	self->max_elevation = 0.0;
	self->min_elevation = 0.0;
	self->points = NULL;
	self->priv->last = NULL;
	self->top = NULL;
	self->bottom = NULL;
}


static void gpx_track_finalize (GObject* obj) {
	GpxTrack * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GPX_TYPE_TRACK, GpxTrack);
	_g_free0 (self->priv->_name);
	__g_list_free__gpx_point_unref0_0 (self->points);
	_gpx_point_unref0 (self->priv->last);
	_gpx_point_unref0 (self->top);
	_gpx_point_unref0 (self->bottom);
	G_OBJECT_CLASS (gpx_track_parent_class)->finalize (obj);
}


/**
     * This class represents a Track in a gpx file.
     * The tracks contains the points connecting everything together.
     * Info like total distance, average speed, moving speed/time etc are available.
     */
GType gpx_track_get_type (void) {
	static volatile gsize gpx_track_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_track_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GpxTrackClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gpx_track_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GpxTrack), 0, (GInstanceInitFunc) gpx_track_instance_init, NULL };
		GType gpx_track_type_id;
		gpx_track_type_id = g_type_register_static (G_TYPE_OBJECT, "GpxTrack", &g_define_type_info, 0);
		g_once_init_leave (&gpx_track_type_id__volatile, gpx_track_type_id);
	}
	return gpx_track_type_id__volatile;
}


static void _vala_gpx_track_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GpxTrack * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GPX_TYPE_TRACK, GpxTrack);
	switch (property_id) {
		case GPX_TRACK_NAME:
		g_value_set_string (value, gpx_track_get_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gpx_track_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GpxTrack * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GPX_TYPE_TRACK, GpxTrack);
	switch (property_id) {
		case GPX_TRACK_NAME:
		gpx_track_set_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


GQuark gpx_file_error_quark (void) {
	return g_quark_from_static_string ("gpx_file_error-quark");
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


/**
         * Helpers
         */
gchar* gpx_file_base_get_uri (GpxFileBase* self) {
	gchar* result = NULL;
	GFile* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->file;
	_tmp1_ = g_file_get_uri (_tmp0_);
	result = _tmp1_;
	return result;
}


gchar* gpx_file_base_get_basename (GpxFileBase* self) {
	gchar* result = NULL;
	GFile* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->file;
	_tmp1_ = g_file_get_basename (_tmp0_);
	result = _tmp1_;
	return result;
}


/** 
         * Accessors
         */
GList* gpx_file_base_get_tracks (GpxFileBase* self) {
	GList* result = NULL;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->tracks;
	result = _tmp0_;
	return result;
}


GList* gpx_file_base_get_waypoints (GpxFileBase* self) {
	GList* result = NULL;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->waypoints;
	result = _tmp0_;
	return result;
}


GList* gpx_file_base_get_routes (GpxFileBase* self) {
	GList* result = NULL;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->routes;
	result = _tmp0_;
	return result;
}


GpxFileBase* gpx_file_base_construct (GType object_type) {
	GpxFileBase * self = NULL;
	self = (GpxFileBase*) g_object_new (object_type, NULL);
	return self;
}


static void gpx_file_base_class_init (GpxFileBaseClass * klass) {
	gpx_file_base_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = gpx_file_base_finalize;
}


static void gpx_file_base_instance_init (GpxFileBase * self) {
	self->tracks = NULL;
	self->waypoints = NULL;
	self->routes = NULL;
	self->file = NULL;
}


static void gpx_file_base_finalize (GObject* obj) {
	GpxFileBase * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GPX_TYPE_FILE_BASE, GpxFileBase);
	__g_list_free__g_object_unref0_0 (self->tracks);
	__g_list_free__gpx_point_unref0_0 (self->waypoints);
	__g_list_free__g_object_unref0_0 (self->routes);
	_g_object_unref0 (self->file);
	G_OBJECT_CLASS (gpx_file_base_parent_class)->finalize (obj);
}


/**
     * This is the top level class representing the gpx file it self.
     * This contains a list of tracks and waypoints.
     */
GType gpx_file_base_get_type (void) {
	static volatile gsize gpx_file_base_type_id__volatile = 0;
	if (g_once_init_enter (&gpx_file_base_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GpxFileBaseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gpx_file_base_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GpxFileBase), 0, (GInstanceInitFunc) gpx_file_base_instance_init, NULL };
		GType gpx_file_base_type_id;
		gpx_file_base_type_id = g_type_register_static (G_TYPE_OBJECT, "GpxFileBase", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&gpx_file_base_type_id__volatile, gpx_file_base_type_id);
	}
	return gpx_file_base_type_id__volatile;
}


/**
     * @param file A GLib.File to open.
     * 
     * Tries to open the file.. check extension, if that fails, try it.
     *
     * @returns a file.
     * @throws a FileError
     */
GpxFileBase* gpx_file_open (GFile* path, GError** error) {
	GpxFileBase* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	{
		GFile* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		GFile* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_ = FALSE;
		GpxFileBase* f = NULL;
		GFile* _tmp16_ = NULL;
		GpxFitFile* _tmp17_ = NULL;
		_tmp0_ = path;
		_tmp1_ = g_file_get_uri (_tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_str_has_suffix (_tmp2_, "fit");
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		if (_tmp4_) {
			GpxFitFile* _tmp5_ = NULL;
			GFile* _tmp6_ = NULL;
			GpxFitFile* _tmp7_ = NULL;
			GpxFitFile* _tmp8_ = NULL;
			_tmp6_ = path;
			_tmp7_ = gpx_fit_file_new (_tmp6_, &_inner_error_);
			_tmp5_ = _tmp7_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch0_g_error;
			}
			_tmp8_ = _tmp5_;
			_tmp5_ = NULL;
			result = (GpxFileBase*) _tmp8_;
			_g_object_unref0 (_tmp5_);
			return result;
		}
		_tmp9_ = path;
		_tmp10_ = g_file_get_uri (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_str_has_suffix (_tmp11_, "gpx");
		_tmp13_ = _tmp12_;
		_g_free0 (_tmp11_);
		if (_tmp13_) {
			GFile* _tmp14_ = NULL;
			GpxXmlFile* _tmp15_ = NULL;
			_tmp14_ = path;
			_tmp15_ = gpx_xml_file_new (_tmp14_);
			result = (GpxFileBase*) _tmp15_;
			return result;
		}
		_tmp16_ = path;
		_tmp17_ = gpx_fit_file_new (_tmp16_, &_inner_error_);
		f = (GpxFileBase*) _tmp17_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
		result = f;
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* err = NULL;
		GFile* _tmp18_ = NULL;
		GpxXmlFile* _tmp19_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp18_ = path;
		_tmp19_ = gpx_xml_file_new (_tmp18_);
		result = (GpxFileBase*) _tmp19_;
		_g_error_free0 (err);
		return result;
	}
	__finally0:
	if (_inner_error_->domain == GPX_FILE_ERROR) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}



